// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: kudu/rpc/rpc_header.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Knet.Kudu.Client.Protobuf.Rpc {

  /// <summary>Holder for reflection information generated from kudu/rpc/rpc_header.proto</summary>
  public static partial class RpcHeaderReflection {

    #region Descriptor
    /// <summary>File descriptor for kudu/rpc/rpc_header.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RpcHeaderReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChlrdWR1L3JwYy9ycGNfaGVhZGVyLnByb3RvEghrdWR1LnJwYxogZ29vZ2xl",
            "L3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG8aGWt1ZHUvc2VjdXJpdHkvdG9r",
            "ZW4ucHJvdG8aF2t1ZHUvdXRpbC9wYl91dGlsLnByb3RvIj4KEVVzZXJJbmZv",
            "cm1hdGlvblBCEhYKDmVmZmVjdGl2ZV91c2VyGAEgASgJEhEKCXJlYWxfdXNl",
            "chgCIAIoCSJtChNDb25uZWN0aW9uQ29udGV4dFBCEjkKFERFUFJFQ0FURURf",
            "dXNlcl9pbmZvGAIgASgLMhsua3VkdS5ycGMuVXNlckluZm9ybWF0aW9uUEIS",
            "GwoNZW5jb2RlZF9ub25jZRgDIAEoDEIEiLUYASLtAQoUQXV0aGVudGljYXRp",
            "b25UeXBlUEISMwoEc2FzbBgBIAEoCzIjLmt1ZHUucnBjLkF1dGhlbnRpY2F0",
            "aW9uVHlwZVBCLlNhc2xIABI1CgV0b2tlbhgCIAEoCzIkLmt1ZHUucnBjLkF1",
            "dGhlbnRpY2F0aW9uVHlwZVBCLlRva2VuSAASQQoLY2VydGlmaWNhdGUYAyAB",
            "KAsyKi5rdWR1LnJwYy5BdXRoZW50aWNhdGlvblR5cGVQQi5DZXJ0aWZpY2F0",
            "ZUgAGgYKBFNhc2waBwoFVG9rZW4aDQoLQ2VydGlmaWNhdGVCBgoEdHlwZSLJ",
            "BAoLTmVnb3RpYXRlUEISNAoSc3VwcG9ydGVkX2ZlYXR1cmVzGAEgAygOMhgu",
            "a3VkdS5ycGMuUnBjRmVhdHVyZUZsYWcSMQoEc3RlcBgCIAIoDjIjLmt1ZHUu",
            "cnBjLk5lZ290aWF0ZVBCLk5lZ290aWF0ZVN0ZXASEwoFdG9rZW4YAyABKAxC",
            "BIi1GAESGwoNdGxzX2hhbmRzaGFrZRgFIAEoDEIEiLUYARIeChBjaGFubmVs",
            "X2JpbmRpbmdzGAYgASgMQgSItRgBEhMKBW5vbmNlGAkgASgMQgSItRgBEjwK",
            "D3Nhc2xfbWVjaGFuaXNtcxgEIAMoCzIjLmt1ZHUucnBjLk5lZ290aWF0ZVBC",
            "LlNhc2xNZWNoYW5pc20SMwoLYXV0aG5fdHlwZXMYByADKAsyHi5rdWR1LnJw",
            "Yy5BdXRoZW50aWNhdGlvblR5cGVQQhIxCgthdXRobl90b2tlbhgIIAEoCzIc",
            "Lmt1ZHUuc2VjdXJpdHkuU2lnbmVkVG9rZW5QQhoiCg1TYXNsTWVjaGFuaXNt",
            "EhEKCW1lY2hhbmlzbRgCIAIoCSKfAQoNTmVnb3RpYXRlU3RlcBIMCgdVTktO",
            "T1dOEOcHEg0KCU5FR09USUFURRABEhAKDFNBU0xfU1VDQ0VTUxAAEhEKDVNB",
            "U0xfSU5JVElBVEUQAhISCg5TQVNMX0NIQUxMRU5HRRADEhEKDVNBU0xfUkVT",
            "UE9OU0UQBBIRCg1UTFNfSEFORFNIQUtFEAUSEgoOVE9LRU5fRVhDSEFOR0UQ",
            "BiI7Cg5SZW1vdGVNZXRob2RQQhIUCgxzZXJ2aWNlX25hbWUYASACKAkSEwoL",
            "bWV0aG9kX25hbWUYAiACKAkiZQoLUmVxdWVzdElkUEISEQoJY2xpZW50X2lk",
            "GAEgAigJEg4KBnNlcV9ubxgCIAIoAxIfChdmaXJzdF9pbmNvbXBsZXRlX3Nl",
            "cV9ubxgDIAIoAxISCgphdHRlbXB0X25vGAQgAigDIs0BCg1SZXF1ZXN0SGVh",
            "ZGVyEg8KB2NhbGxfaWQYAyACKAUSLwoNcmVtb3RlX21ldGhvZBgGIAEoCzIY",
            "Lmt1ZHUucnBjLlJlbW90ZU1ldGhvZFBCEhYKDnRpbWVvdXRfbWlsbGlzGAog",
            "ASgNEh4KFnJlcXVpcmVkX2ZlYXR1cmVfZmxhZ3MYCyADKA0SKQoKcmVxdWVz",
            "dF9pZBgPIAEoCzIVLmt1ZHUucnBjLlJlcXVlc3RJZFBCEhcKD3NpZGVjYXJf",
            "b2Zmc2V0cxgQIAMoDSJTCg5SZXNwb25zZUhlYWRlchIPCgdjYWxsX2lkGAEg",
            "AigFEhcKCGlzX2Vycm9yGAIgASgIOgVmYWxzZRIXCg9zaWRlY2FyX29mZnNl",
            "dHMYAyADKA0ivQQKDUVycm9yU3RhdHVzUEISDwoHbWVzc2FnZRgBIAIoCRI0",
            "CgRjb2RlGAIgASgOMiYua3VkdS5ycGMuRXJyb3JTdGF0dXNQQi5ScGNFcnJv",
            "ckNvZGVQQhIhChl1bnN1cHBvcnRlZF9mZWF0dXJlX2ZsYWdzGAMgAygNIrcD",
            "Cg5ScGNFcnJvckNvZGVQQhIRCg1GQVRBTF9VTktOT1dOEAoSFQoRRVJST1Jf",
            "QVBQTElDQVRJT04QARIYChRFUlJPUl9OT19TVUNIX01FVEhPRBACEhkKFUVS",
            "Uk9SX05PX1NVQ0hfU0VSVklDRRADEhkKFUVSUk9SX1NFUlZFUl9UT09fQlVT",
            "WRAEEhkKFUVSUk9SX0lOVkFMSURfUkVRVUVTVBAFEhcKE0VSUk9SX1JFUVVF",
            "U1RfU1RBTEUQBhIVChFFUlJPUl9VTkFWQUlMQUJMRRAHEiUKIUVSUk9SX0lO",
            "VkFMSURfQVVUSE9SSVpBVElPTl9UT0tFThAREh4KGkZBVEFMX1NFUlZFUl9T",
            "SFVUVElOR19ET1dOEAsSHAoYRkFUQUxfSU5WQUxJRF9SUENfSEVBREVSEAwS",
            "HwobRkFUQUxfREVTRVJJQUxJWklOR19SRVFVRVNUEA0SGgoWRkFUQUxfVkVS",
            "U0lPTl9NSVNNQVRDSBAOEhYKEkZBVEFMX1VOQVVUSE9SSVpFRBAPEiYKIkZB",
            "VEFMX0lOVkFMSURfQVVUSEVOVElDQVRJT05fVE9LRU4QECoICGQQgICAgAIq",
            "YgoOUnBjRmVhdHVyZUZsYWcSCwoHVU5LTk9XThAAEh0KGUFQUExJQ0FUSU9O",
            "X0ZFQVRVUkVfRkxBR1MQARIHCgNUTFMQAhIbChdUTFNfQVVUSEVOVElDQVRJ",
            "T05fT05MWRADOkEKEHRyYWNrX3JwY19yZXN1bHQSHi5nb29nbGUucHJvdG9i",
            "dWYuTWV0aG9kT3B0aW9ucxjWhgMgASgIOgVmYWxzZTo2CgxhdXRoel9tZXRo",
            "b2QSHi5nb29nbGUucHJvdG9idWYuTWV0aG9kT3B0aW9ucxjXhgMgASgJOj8K",
            "FGRlZmF1bHRfYXV0aHpfbWV0aG9kEh8uZ29vZ2xlLnByb3RvYnVmLlNlcnZp",
            "Y2VPcHRpb25zGNeGAyABKAlCNwoTb3JnLmFwYWNoZS5rdWR1LnJwY0gBqgId",
            "S25ldC5LdWR1LkNsaWVudC5Qcm90b2J1Zi5ScGM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.Reflection.DescriptorReflection.Descriptor, global::Knet.Kudu.Client.Protobuf.Security.TokenReflection.Descriptor, global::Knet.Kudu.Client.Protobuf.PbUtilReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Knet.Kudu.Client.Protobuf.Rpc.RpcFeatureFlag), }, new pb::Extension[] { RpcHeaderExtensions.TrackRpcResult, RpcHeaderExtensions.AuthzMethod, RpcHeaderExtensions.DefaultAuthzMethod }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.UserInformationPB), global::Knet.Kudu.Client.Protobuf.Rpc.UserInformationPB.Parser, new[]{ "EffectiveUser", "RealUser" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.ConnectionContextPB), global::Knet.Kudu.Client.Protobuf.Rpc.ConnectionContextPB.Parser, new[]{ "DEPRECATEDUserInfo", "EncodedNonce" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB), global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Parser, new[]{ "Sasl", "Token", "Certificate" }, new[]{ "Type" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl), global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token), global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate), global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate.Parser, null, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB), global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Parser, new[]{ "SupportedFeatures", "Step", "Token", "TlsHandshake", "ChannelBindings", "Nonce", "SaslMechanisms", "AuthnTypes", "AuthnToken" }, null, new[]{ typeof(global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.NegotiateStep) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism), global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism.Parser, new[]{ "Mechanism" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.RemoteMethodPB), global::Knet.Kudu.Client.Protobuf.Rpc.RemoteMethodPB.Parser, new[]{ "ServiceName", "MethodName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.RequestIdPB), global::Knet.Kudu.Client.Protobuf.Rpc.RequestIdPB.Parser, new[]{ "ClientId", "SeqNo", "FirstIncompleteSeqNo", "AttemptNo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.RequestHeader), global::Knet.Kudu.Client.Protobuf.Rpc.RequestHeader.Parser, new[]{ "CallId", "RemoteMethod", "TimeoutMillis", "RequiredFeatureFlags", "RequestId", "SidecarOffsets" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.ResponseHeader), global::Knet.Kudu.Client.Protobuf.Rpc.ResponseHeader.Parser, new[]{ "CallId", "IsError", "SidecarOffsets" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB), global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Parser, new[]{ "Message", "Code", "UnsupportedFeatureFlags" }, null, new[]{ typeof(global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Types.RpcErrorCodePB) }, null, null)
          }));
    }
    #endregion

  }
  /// <summary>Holder for extension identifiers generated from the top level of kudu/rpc/rpc_header.proto</summary>
  public static partial class RpcHeaderExtensions {
    /// <summary>
    /// An option for RPC methods that allows to set whether that method's
    /// RPC results should be tracked with a ResultTracker.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.MethodOptions, bool> TrackRpcResult =
      new pb::Extension<global::Google.Protobuf.Reflection.MethodOptions, bool>(50006, pb::FieldCodec.ForBool(400048, false));
    /// <summary>
    /// An option to set the authorization method for this particular
    /// RPC method. If this is not specified, the service's 'default_authz_method'
    /// is used.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.MethodOptions, string> AuthzMethod =
      new pb::Extension<global::Google.Protobuf.Reflection.MethodOptions, string>(50007, pb::FieldCodec.ForString(400058, ""));
    /// <summary>
    /// Set the default authorization method for the RPCs in this service.
    /// If this is not set, then the default authorization is to allow all
    /// RPCs.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.ServiceOptions, string> DefaultAuthzMethod =
      new pb::Extension<global::Google.Protobuf.Reflection.ServiceOptions, string>(50007, pb::FieldCodec.ForString(400058, ""));
  }

  #region Enums
  /// <summary>
  /// Features supported by the RPC system itself.
  ///
  /// Note that this should be used to evolve the RPC _system_, not the semantics
  /// or compatibility of individual calls.
  ///
  /// For example, if we were to add a feature like call or response wire
  /// compression in the future, we could add a flag here to indicate that the
  /// client or server supports that feature. Optional features which may safely be
  /// ignored by the receiver do not need a feature flag, instead the optional
  /// field feature of ProtoBuf may be utilized.
  /// </summary>
  public enum RpcFeatureFlag {
    [pbr::OriginalName("UNKNOWN")] Unknown = 0,
    /// <summary>
    /// The RPC system is required to support application feature flags in the
    /// request and response headers.
    /// </summary>
    [pbr::OriginalName("APPLICATION_FEATURE_FLAGS")] ApplicationFeatureFlags = 1,
    /// <summary>
    /// The RPC system supports TLS protected connections. If both sides support
    /// this flag, the connection will automatically be wrapped in a TLS protected
    /// channel following a TLS handshake.
    /// </summary>
    [pbr::OriginalName("TLS")] Tls = 2,
    /// <summary>
    /// If both sides advertise TLS_AUTHENTICATION_ONLY, this means that they
    /// agree that, after handshaking TLS, they will *not* wrap the connection
    /// in a TLS-protected channel. Instead, they will use TLS only for its
    /// handshake-based authentication.
    ///
    /// This is currently used for loopback connections only, so that compute
    /// frameworks which schedule for locality don't pay encryption overhead.
    /// </summary>
    [pbr::OriginalName("TLS_AUTHENTICATION_ONLY")] TlsAuthenticationOnly = 3,
  }

  #endregion

  #region Messages
  /// <summary>
  /// User Information proto.  Included in ConnectionContextPB on connection setup.
  /// </summary>
  public sealed partial class UserInformationPB : pb::IMessage<UserInformationPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<UserInformationPB> _parser = new pb::MessageParser<UserInformationPB>(() => new UserInformationPB());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UserInformationPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserInformationPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserInformationPB(UserInformationPB other) : this() {
      effectiveUser_ = other.effectiveUser_;
      realUser_ = other.realUser_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserInformationPB Clone() {
      return new UserInformationPB(this);
    }

    /// <summary>Field number for the "effective_user" field.</summary>
    public const int EffectiveUserFieldNumber = 1;
    private readonly static string EffectiveUserDefaultValue = "";

    private string effectiveUser_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string EffectiveUser {
      get { return effectiveUser_ ?? EffectiveUserDefaultValue; }
      set {
        effectiveUser_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "effective_user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEffectiveUser {
      get { return effectiveUser_ != null; }
    }
    /// <summary>Clears the value of the "effective_user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEffectiveUser() {
      effectiveUser_ = null;
    }

    /// <summary>Field number for the "real_user" field.</summary>
    public const int RealUserFieldNumber = 2;
    private readonly static string RealUserDefaultValue = "";

    private string realUser_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RealUser {
      get { return realUser_ ?? RealUserDefaultValue; }
      set {
        realUser_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "real_user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRealUser {
      get { return realUser_ != null; }
    }
    /// <summary>Clears the value of the "real_user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRealUser() {
      realUser_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UserInformationPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UserInformationPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EffectiveUser != other.EffectiveUser) return false;
      if (RealUser != other.RealUser) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEffectiveUser) hash ^= EffectiveUser.GetHashCode();
      if (HasRealUser) hash ^= RealUser.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEffectiveUser) {
        output.WriteRawTag(10);
        output.WriteString(EffectiveUser);
      }
      if (HasRealUser) {
        output.WriteRawTag(18);
        output.WriteString(RealUser);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasEffectiveUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EffectiveUser);
      }
      if (HasRealUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RealUser);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UserInformationPB other) {
      if (other == null) {
        return;
      }
      if (other.HasEffectiveUser) {
        EffectiveUser = other.EffectiveUser;
      }
      if (other.HasRealUser) {
        RealUser = other.RealUser;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            EffectiveUser = input.ReadString();
            break;
          }
          case 18: {
            RealUser = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The connection context is sent as part of the connection establishment.
  /// It establishes the context for ALL RPC calls within the connection.
  /// This is sent on connection setup after the connection preamble is sent
  /// and SASL has been negotiated.
  /// No response is sent from the server to the client.
  /// </summary>
  public sealed partial class ConnectionContextPB : pb::IMessage<ConnectionContextPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<ConnectionContextPB> _parser = new pb::MessageParser<ConnectionContextPB>(() => new ConnectionContextPB());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConnectionContextPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConnectionContextPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConnectionContextPB(ConnectionContextPB other) : this() {
      dEPRECATEDUserInfo_ = other.dEPRECATEDUserInfo_ != null ? other.dEPRECATEDUserInfo_.Clone() : null;
      encodedNonce_ = other.encodedNonce_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConnectionContextPB Clone() {
      return new ConnectionContextPB(this);
    }

    /// <summary>Field number for the "DEPRECATED_user_info" field.</summary>
    public const int DEPRECATEDUserInfoFieldNumber = 2;
    private global::Knet.Kudu.Client.Protobuf.Rpc.UserInformationPB dEPRECATEDUserInfo_;
    /// <summary>
    /// UserInfo beyond what is determined as part of security handshake
    /// at connection time (kerberos, tokens etc).
    ///
    /// DEPRECATED: No longer used in Kudu 1.1 and later.
    /// The 'real_user' should be taken from the SASL negotiation.
    /// Impersonation (effective user) was never supported, so we'll have
    /// to add that back at some point later.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.UserInformationPB DEPRECATEDUserInfo {
      get { return dEPRECATEDUserInfo_; }
      set {
        dEPRECATEDUserInfo_ = value;
      }
    }

    /// <summary>Field number for the "encoded_nonce" field.</summary>
    public const int EncodedNonceFieldNumber = 3;
    private readonly static pb::ByteString EncodedNonceDefaultValue = pb::ByteString.Empty;

    private pb::ByteString encodedNonce_;
    /// <summary>
    /// If the server sends a nonce to the client during the SASL_SUCCESS
    /// negotiation step, the client is required to encode it with SASL integrity
    /// protection and return it in this field. The nonce protects the server
    /// against a Kerberos replay attack.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString EncodedNonce {
      get { return encodedNonce_ ?? EncodedNonceDefaultValue; }
      set {
        encodedNonce_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "encoded_nonce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEncodedNonce {
      get { return encodedNonce_ != null; }
    }
    /// <summary>Clears the value of the "encoded_nonce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEncodedNonce() {
      encodedNonce_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConnectionContextPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConnectionContextPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(DEPRECATEDUserInfo, other.DEPRECATEDUserInfo)) return false;
      if (EncodedNonce != other.EncodedNonce) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (dEPRECATEDUserInfo_ != null) hash ^= DEPRECATEDUserInfo.GetHashCode();
      if (HasEncodedNonce) hash ^= EncodedNonce.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (dEPRECATEDUserInfo_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DEPRECATEDUserInfo);
      }
      if (HasEncodedNonce) {
        output.WriteRawTag(26);
        output.WriteBytes(EncodedNonce);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (dEPRECATEDUserInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DEPRECATEDUserInfo);
      }
      if (HasEncodedNonce) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncodedNonce);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConnectionContextPB other) {
      if (other == null) {
        return;
      }
      if (other.dEPRECATEDUserInfo_ != null) {
        if (dEPRECATEDUserInfo_ == null) {
          DEPRECATEDUserInfo = new global::Knet.Kudu.Client.Protobuf.Rpc.UserInformationPB();
        }
        DEPRECATEDUserInfo.MergeFrom(other.DEPRECATEDUserInfo);
      }
      if (other.HasEncodedNonce) {
        EncodedNonce = other.EncodedNonce;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (dEPRECATEDUserInfo_ == null) {
              DEPRECATEDUserInfo = new global::Knet.Kudu.Client.Protobuf.Rpc.UserInformationPB();
            }
            input.ReadMessage(DEPRECATEDUserInfo);
            break;
          }
          case 26: {
            EncodedNonce = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// An authentication type. This is modeled as a oneof in case any of these
  /// authentication types, or any authentication types in the future, need to add
  /// extra type-specific parameters during negotiation.
  /// </summary>
  public sealed partial class AuthenticationTypePB : pb::IMessage<AuthenticationTypePB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<AuthenticationTypePB> _parser = new pb::MessageParser<AuthenticationTypePB>(() => new AuthenticationTypePB());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AuthenticationTypePB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthenticationTypePB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthenticationTypePB(AuthenticationTypePB other) : this() {
      switch (other.TypeCase) {
        case TypeOneofCase.Sasl:
          Sasl = other.Sasl.Clone();
          break;
        case TypeOneofCase.Token:
          Token = other.Token.Clone();
          break;
        case TypeOneofCase.Certificate:
          Certificate = other.Certificate.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthenticationTypePB Clone() {
      return new AuthenticationTypePB(this);
    }

    /// <summary>Field number for the "sasl" field.</summary>
    public const int SaslFieldNumber = 1;
    /// <summary>
    /// The server and client mutually authenticate via SASL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl Sasl {
      get { return typeCase_ == TypeOneofCase.Sasl ? (global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Sasl;
      }
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 2;
    /// <summary>
    /// The server authenticates the client via a signed token, and the client
    /// authenticates the server by verifying its certificate has been signed by
    /// a trusted CA.
    ///
    /// Token authentication requires the connection to be TLS encrypted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token Token {
      get { return typeCase_ == TypeOneofCase.Token ? (global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Token;
      }
    }

    /// <summary>Field number for the "certificate" field.</summary>
    public const int CertificateFieldNumber = 3;
    /// <summary>
    /// The server and client mutually authenticate by certificate.
    ///
    /// Certificate authentication requires the connection to be TLS encrypted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate Certificate {
      get { return typeCase_ == TypeOneofCase.Certificate ? (global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Certificate;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      Sasl = 1,
      Token = 2,
      Certificate = 3,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AuthenticationTypePB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AuthenticationTypePB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Sasl, other.Sasl)) return false;
      if (!object.Equals(Token, other.Token)) return false;
      if (!object.Equals(Certificate, other.Certificate)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (typeCase_ == TypeOneofCase.Sasl) hash ^= Sasl.GetHashCode();
      if (typeCase_ == TypeOneofCase.Token) hash ^= Token.GetHashCode();
      if (typeCase_ == TypeOneofCase.Certificate) hash ^= Certificate.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (typeCase_ == TypeOneofCase.Sasl) {
        output.WriteRawTag(10);
        output.WriteMessage(Sasl);
      }
      if (typeCase_ == TypeOneofCase.Token) {
        output.WriteRawTag(18);
        output.WriteMessage(Token);
      }
      if (typeCase_ == TypeOneofCase.Certificate) {
        output.WriteRawTag(26);
        output.WriteMessage(Certificate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (typeCase_ == TypeOneofCase.Sasl) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sasl);
      }
      if (typeCase_ == TypeOneofCase.Token) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Token);
      }
      if (typeCase_ == TypeOneofCase.Certificate) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Certificate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AuthenticationTypePB other) {
      if (other == null) {
        return;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.Sasl:
          if (Sasl == null) {
            Sasl = new global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl();
          }
          Sasl.MergeFrom(other.Sasl);
          break;
        case TypeOneofCase.Token:
          if (Token == null) {
            Token = new global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token();
          }
          Token.MergeFrom(other.Token);
          break;
        case TypeOneofCase.Certificate:
          if (Certificate == null) {
            Certificate = new global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate();
          }
          Certificate.MergeFrom(other.Certificate);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl subBuilder = new global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Sasl();
            if (typeCase_ == TypeOneofCase.Sasl) {
              subBuilder.MergeFrom(Sasl);
            }
            input.ReadMessage(subBuilder);
            Sasl = subBuilder;
            break;
          }
          case 18: {
            global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token subBuilder = new global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Token();
            if (typeCase_ == TypeOneofCase.Token) {
              subBuilder.MergeFrom(Token);
            }
            input.ReadMessage(subBuilder);
            Token = subBuilder;
            break;
          }
          case 26: {
            global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate subBuilder = new global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Types.Certificate();
            if (typeCase_ == TypeOneofCase.Certificate) {
              subBuilder.MergeFrom(Certificate);
            }
            input.ReadMessage(subBuilder);
            Certificate = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the AuthenticationTypePB message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Sasl : pb::IMessage<Sasl>
          , pb::IBufferMessage
      {
        private static readonly pb::MessageParser<Sasl> _parser = new pb::MessageParser<Sasl>(() => new Sasl());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Sasl> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sasl() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sasl(Sasl other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sasl Clone() {
          return new Sasl(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Sasl);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Sasl other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          output.WriteRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Sasl other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          input.ReadRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }

      }

      public sealed partial class Token : pb::IMessage<Token>
          , pb::IBufferMessage
      {
        private static readonly pb::MessageParser<Token> _parser = new pb::MessageParser<Token>(() => new Token());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Token> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Token() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Token(Token other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Token Clone() {
          return new Token(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Token);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Token other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          output.WriteRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Token other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          input.ReadRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }

      }

      public sealed partial class Certificate : pb::IMessage<Certificate>
          , pb::IBufferMessage
      {
        private static readonly pb::MessageParser<Certificate> _parser = new pb::MessageParser<Certificate>(() => new Certificate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Certificate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Certificate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Certificate(Certificate other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Certificate Clone() {
          return new Certificate(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Certificate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Certificate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          output.WriteRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Certificate other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          input.ReadRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Message type passed back &amp; forth for the SASL negotiation.
  /// </summary>
  public sealed partial class NegotiatePB : pb::IMessage<NegotiatePB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<NegotiatePB> _parser = new pb::MessageParser<NegotiatePB>(() => new NegotiatePB());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NegotiatePB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NegotiatePB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NegotiatePB(NegotiatePB other) : this() {
      _hasBits0 = other._hasBits0;
      supportedFeatures_ = other.supportedFeatures_.Clone();
      step_ = other.step_;
      token_ = other.token_;
      tlsHandshake_ = other.tlsHandshake_;
      channelBindings_ = other.channelBindings_;
      nonce_ = other.nonce_;
      saslMechanisms_ = other.saslMechanisms_.Clone();
      authnTypes_ = other.authnTypes_.Clone();
      authnToken_ = other.authnToken_ != null ? other.authnToken_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NegotiatePB Clone() {
      return new NegotiatePB(this);
    }

    /// <summary>Field number for the "supported_features" field.</summary>
    public const int SupportedFeaturesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.Rpc.RpcFeatureFlag> _repeated_supportedFeatures_codec
        = pb::FieldCodec.ForEnum(8, x => (int) x, x => (global::Knet.Kudu.Client.Protobuf.Rpc.RpcFeatureFlag) x);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.RpcFeatureFlag> supportedFeatures_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.RpcFeatureFlag>();
    /// <summary>
    /// When the client sends its NEGOTIATE step message, it sends its set of
    /// supported RPC system features. In the response to this message, the server
    /// sends back its own. This allows the two peers to agree on whether newer
    /// extensions of the RPC system may be used on this connection. We use a list
    /// of features rather than a simple version number to make it easier for the
    /// Java and C++ clients to implement features in different orders while still
    /// maintaining compatibility, as well as to simplify backporting of features
    /// out-of-order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.RpcFeatureFlag> SupportedFeatures {
      get { return supportedFeatures_; }
    }

    /// <summary>Field number for the "step" field.</summary>
    public const int StepFieldNumber = 2;
    private readonly static global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.NegotiateStep StepDefaultValue = global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.NegotiateStep.Unknown;

    private global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.NegotiateStep step_;
    /// <summary>
    /// The current negotiation step.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.NegotiateStep Step {
      get { if ((_hasBits0 & 1) != 0) { return step_; } else { return StepDefaultValue; } }
      set {
        _hasBits0 |= 1;
        step_ = value;
      }
    }
    /// <summary>Gets whether the "step" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStep {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "step" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStep() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 3;
    private readonly static pb::ByteString TokenDefaultValue = pb::ByteString.Empty;

    private pb::ByteString token_;
    /// <summary>
    /// The SASL token, containing either the challenge during the SASL_CHALLENGE
    /// step, or the response during the SASL_RESPONSE step.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Token {
      get { return token_ ?? TokenDefaultValue; }
      set {
        token_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasToken {
      get { return token_ != null; }
    }
    /// <summary>Clears the value of the "token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearToken() {
      token_ = null;
    }

    /// <summary>Field number for the "tls_handshake" field.</summary>
    public const int TlsHandshakeFieldNumber = 5;
    private readonly static pb::ByteString TlsHandshakeDefaultValue = pb::ByteString.Empty;

    private pb::ByteString tlsHandshake_;
    /// <summary>
    /// During the TLS_HANDSHAKE step, contains the TLS handshake message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString TlsHandshake {
      get { return tlsHandshake_ ?? TlsHandshakeDefaultValue; }
      set {
        tlsHandshake_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "tls_handshake" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTlsHandshake {
      get { return tlsHandshake_ != null; }
    }
    /// <summary>Clears the value of the "tls_handshake" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTlsHandshake() {
      tlsHandshake_ = null;
    }

    /// <summary>Field number for the "channel_bindings" field.</summary>
    public const int ChannelBindingsFieldNumber = 6;
    private readonly static pb::ByteString ChannelBindingsDefaultValue = pb::ByteString.Empty;

    private pb::ByteString channelBindings_;
    /// <summary>
    /// The tls-server-end-point channel bindings as specified in RFC 5929.  Sent
    /// from the server to the client during the SASL_SUCCESS step when the
    /// Kerberos (GSSAPI) SASL mechanism is used with TLS, in order to bind the
    /// Kerberos authenticated channel to the TLS channel. The value is integrity
    /// protected through SASL. The client is responsible for validating that the
    /// value matches the expected value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ChannelBindings {
      get { return channelBindings_ ?? ChannelBindingsDefaultValue; }
      set {
        channelBindings_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "channel_bindings" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChannelBindings {
      get { return channelBindings_ != null; }
    }
    /// <summary>Clears the value of the "channel_bindings" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChannelBindings() {
      channelBindings_ = null;
    }

    /// <summary>Field number for the "nonce" field.</summary>
    public const int NonceFieldNumber = 9;
    private readonly static pb::ByteString NonceDefaultValue = pb::ByteString.Empty;

    private pb::ByteString nonce_;
    /// <summary>
    /// A random nonce sent from the server to the client during the SASL_SUCCESS
    /// step when the Kerberos (GSSAPI) SASL mechanism is used with TLS. The nonce
    /// must be sent back to the server, wrapped in SASL integrity protection, as
    /// part of the connection context.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Nonce {
      get { return nonce_ ?? NonceDefaultValue; }
      set {
        nonce_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nonce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNonce {
      get { return nonce_ != null; }
    }
    /// <summary>Clears the value of the "nonce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNonce() {
      nonce_ = null;
    }

    /// <summary>Field number for the "sasl_mechanisms" field.</summary>
    public const int SaslMechanismsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism> _repeated_saslMechanisms_codec
        = pb::FieldCodec.ForMessage(34, global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism> saslMechanisms_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism>();
    /// <summary>
    /// During the NEGOTIATE step, contains the supported SASL mechanisms.
    /// During the SASL_INITIATE step, contains the single chosen SASL mechanism.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.SaslMechanism> SaslMechanisms {
      get { return saslMechanisms_; }
    }

    /// <summary>Field number for the "authn_types" field.</summary>
    public const int AuthnTypesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB> _repeated_authnTypes_codec
        = pb::FieldCodec.ForMessage(58, global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB> authnTypes_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB>();
    /// <summary>
    /// During the client to server NEGOTIATE step, contains the supported authentication types.
    /// During the server to client NEGOTIATE step, contains the chosen authentication type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Rpc.AuthenticationTypePB> AuthnTypes {
      get { return authnTypes_; }
    }

    /// <summary>Field number for the "authn_token" field.</summary>
    public const int AuthnTokenFieldNumber = 8;
    private global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB authnToken_;
    /// <summary>
    /// During the TOKEN_EXCHANGE step, contains the client's signed authentication token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB AuthnToken {
      get { return authnToken_; }
      set {
        authnToken_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NegotiatePB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NegotiatePB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!supportedFeatures_.Equals(other.supportedFeatures_)) return false;
      if (Step != other.Step) return false;
      if (Token != other.Token) return false;
      if (TlsHandshake != other.TlsHandshake) return false;
      if (ChannelBindings != other.ChannelBindings) return false;
      if (Nonce != other.Nonce) return false;
      if(!saslMechanisms_.Equals(other.saslMechanisms_)) return false;
      if(!authnTypes_.Equals(other.authnTypes_)) return false;
      if (!object.Equals(AuthnToken, other.AuthnToken)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= supportedFeatures_.GetHashCode();
      if (HasStep) hash ^= Step.GetHashCode();
      if (HasToken) hash ^= Token.GetHashCode();
      if (HasTlsHandshake) hash ^= TlsHandshake.GetHashCode();
      if (HasChannelBindings) hash ^= ChannelBindings.GetHashCode();
      if (HasNonce) hash ^= Nonce.GetHashCode();
      hash ^= saslMechanisms_.GetHashCode();
      hash ^= authnTypes_.GetHashCode();
      if (authnToken_ != null) hash ^= AuthnToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      supportedFeatures_.WriteTo(ref output, _repeated_supportedFeatures_codec);
      if (HasStep) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Step);
      }
      if (HasToken) {
        output.WriteRawTag(26);
        output.WriteBytes(Token);
      }
      saslMechanisms_.WriteTo(ref output, _repeated_saslMechanisms_codec);
      if (HasTlsHandshake) {
        output.WriteRawTag(42);
        output.WriteBytes(TlsHandshake);
      }
      if (HasChannelBindings) {
        output.WriteRawTag(50);
        output.WriteBytes(ChannelBindings);
      }
      authnTypes_.WriteTo(ref output, _repeated_authnTypes_codec);
      if (authnToken_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AuthnToken);
      }
      if (HasNonce) {
        output.WriteRawTag(74);
        output.WriteBytes(Nonce);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += supportedFeatures_.CalculateSize(_repeated_supportedFeatures_codec);
      if (HasStep) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Step);
      }
      if (HasToken) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Token);
      }
      if (HasTlsHandshake) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(TlsHandshake);
      }
      if (HasChannelBindings) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ChannelBindings);
      }
      if (HasNonce) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Nonce);
      }
      size += saslMechanisms_.CalculateSize(_repeated_saslMechanisms_codec);
      size += authnTypes_.CalculateSize(_repeated_authnTypes_codec);
      if (authnToken_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthnToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NegotiatePB other) {
      if (other == null) {
        return;
      }
      supportedFeatures_.Add(other.supportedFeatures_);
      if (other.HasStep) {
        Step = other.Step;
      }
      if (other.HasToken) {
        Token = other.Token;
      }
      if (other.HasTlsHandshake) {
        TlsHandshake = other.TlsHandshake;
      }
      if (other.HasChannelBindings) {
        ChannelBindings = other.ChannelBindings;
      }
      if (other.HasNonce) {
        Nonce = other.Nonce;
      }
      saslMechanisms_.Add(other.saslMechanisms_);
      authnTypes_.Add(other.authnTypes_);
      if (other.authnToken_ != null) {
        if (authnToken_ == null) {
          AuthnToken = new global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB();
        }
        AuthnToken.MergeFrom(other.AuthnToken);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            supportedFeatures_.AddEntriesFrom(ref input, _repeated_supportedFeatures_codec);
            break;
          }
          case 16: {
            Step = (global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Types.NegotiateStep) input.ReadEnum();
            break;
          }
          case 26: {
            Token = input.ReadBytes();
            break;
          }
          case 34: {
            saslMechanisms_.AddEntriesFrom(ref input, _repeated_saslMechanisms_codec);
            break;
          }
          case 42: {
            TlsHandshake = input.ReadBytes();
            break;
          }
          case 50: {
            ChannelBindings = input.ReadBytes();
            break;
          }
          case 58: {
            authnTypes_.AddEntriesFrom(ref input, _repeated_authnTypes_codec);
            break;
          }
          case 66: {
            if (authnToken_ == null) {
              AuthnToken = new global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB();
            }
            input.ReadMessage(AuthnToken);
            break;
          }
          case 74: {
            Nonce = input.ReadBytes();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the NegotiatePB message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum NegotiateStep {
        [pbr::OriginalName("UNKNOWN")] Unknown = 999,
        [pbr::OriginalName("NEGOTIATE")] Negotiate = 1,
        [pbr::OriginalName("SASL_SUCCESS")] SaslSuccess = 0,
        [pbr::OriginalName("SASL_INITIATE")] SaslInitiate = 2,
        [pbr::OriginalName("SASL_CHALLENGE")] SaslChallenge = 3,
        [pbr::OriginalName("SASL_RESPONSE")] SaslResponse = 4,
        [pbr::OriginalName("TLS_HANDSHAKE")] TlsHandshake = 5,
        [pbr::OriginalName("TOKEN_EXCHANGE")] TokenExchange = 6,
      }

      public sealed partial class SaslMechanism : pb::IMessage<SaslMechanism>
          , pb::IBufferMessage
      {
        private static readonly pb::MessageParser<SaslMechanism> _parser = new pb::MessageParser<SaslMechanism>(() => new SaslMechanism());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SaslMechanism> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Knet.Kudu.Client.Protobuf.Rpc.NegotiatePB.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SaslMechanism() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SaslMechanism(SaslMechanism other) : this() {
          mechanism_ = other.mechanism_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SaslMechanism Clone() {
          return new SaslMechanism(this);
        }

        /// <summary>Field number for the "mechanism" field.</summary>
        public const int MechanismFieldNumber = 2;
        private readonly static string MechanismDefaultValue = "";

        private string mechanism_;
        /// <summary>
        /// The SASL mechanism, i.e. 'PLAIN' or 'GSSAPI'.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Mechanism {
          get { return mechanism_ ?? MechanismDefaultValue; }
          set {
            mechanism_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "mechanism" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMechanism {
          get { return mechanism_ != null; }
        }
        /// <summary>Clears the value of the "mechanism" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMechanism() {
          mechanism_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SaslMechanism);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SaslMechanism other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Mechanism != other.Mechanism) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMechanism) hash ^= Mechanism.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          output.WriteRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasMechanism) {
            output.WriteRawTag(18);
            output.WriteString(Mechanism);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasMechanism) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Mechanism);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SaslMechanism other) {
          if (other == null) {
            return;
          }
          if (other.HasMechanism) {
            Mechanism = other.Mechanism;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          input.ReadRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 18: {
                Mechanism = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class RemoteMethodPB : pb::IMessage<RemoteMethodPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<RemoteMethodPB> _parser = new pb::MessageParser<RemoteMethodPB>(() => new RemoteMethodPB());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RemoteMethodPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemoteMethodPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemoteMethodPB(RemoteMethodPB other) : this() {
      serviceName_ = other.serviceName_;
      methodName_ = other.methodName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemoteMethodPB Clone() {
      return new RemoteMethodPB(this);
    }

    /// <summary>Field number for the "service_name" field.</summary>
    public const int ServiceNameFieldNumber = 1;
    private readonly static string ServiceNameDefaultValue = "";

    private string serviceName_;
    /// <summary>
    /// Service name for the RPC layer.
    /// The client created a proxy with this service name.
    /// Example: kudu.rpc_test.CalculatorService
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServiceName {
      get { return serviceName_ ?? ServiceNameDefaultValue; }
      set {
        serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "service_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasServiceName {
      get { return serviceName_ != null; }
    }
    /// <summary>Clears the value of the "service_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearServiceName() {
      serviceName_ = null;
    }

    /// <summary>Field number for the "method_name" field.</summary>
    public const int MethodNameFieldNumber = 2;
    private readonly static string MethodNameDefaultValue = "";

    private string methodName_;
    /// <summary>
    /// Name of the RPC method.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MethodName {
      get { return methodName_ ?? MethodNameDefaultValue; }
      set {
        methodName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "method_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMethodName {
      get { return methodName_ != null; }
    }
    /// <summary>Clears the value of the "method_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMethodName() {
      methodName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RemoteMethodPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RemoteMethodPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServiceName != other.ServiceName) return false;
      if (MethodName != other.MethodName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasServiceName) hash ^= ServiceName.GetHashCode();
      if (HasMethodName) hash ^= MethodName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasServiceName) {
        output.WriteRawTag(10);
        output.WriteString(ServiceName);
      }
      if (HasMethodName) {
        output.WriteRawTag(18);
        output.WriteString(MethodName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasServiceName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
      }
      if (HasMethodName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MethodName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RemoteMethodPB other) {
      if (other == null) {
        return;
      }
      if (other.HasServiceName) {
        ServiceName = other.ServiceName;
      }
      if (other.HasMethodName) {
        MethodName = other.MethodName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ServiceName = input.ReadString();
            break;
          }
          case 18: {
            MethodName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The Id of a retriable RPC, whose results should be tracked on the server (see result_tracker.h).
  /// This also includes some information that is useful for execution/garbage collection.
  /// </summary>
  public sealed partial class RequestIdPB : pb::IMessage<RequestIdPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<RequestIdPB> _parser = new pb::MessageParser<RequestIdPB>(() => new RequestIdPB());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RequestIdPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestIdPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestIdPB(RequestIdPB other) : this() {
      _hasBits0 = other._hasBits0;
      clientId_ = other.clientId_;
      seqNo_ = other.seqNo_;
      firstIncompleteSeqNo_ = other.firstIncompleteSeqNo_;
      attemptNo_ = other.attemptNo_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestIdPB Clone() {
      return new RequestIdPB(this);
    }

    /// <summary>Field number for the "client_id" field.</summary>
    public const int ClientIdFieldNumber = 1;
    private readonly static string ClientIdDefaultValue = "";

    private string clientId_;
    /// <summary>
    /// The (globally unique) id of the client performing this RPC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClientId {
      get { return clientId_ ?? ClientIdDefaultValue; }
      set {
        clientId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "client_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClientId {
      get { return clientId_ != null; }
    }
    /// <summary>Clears the value of the "client_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClientId() {
      clientId_ = null;
    }

    /// <summary>Field number for the "seq_no" field.</summary>
    public const int SeqNoFieldNumber = 2;
    private readonly static long SeqNoDefaultValue = 0L;

    private long seqNo_;
    /// <summary>
    /// The (per-client unique) sequence number of this RPC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long SeqNo {
      get { if ((_hasBits0 & 1) != 0) { return seqNo_; } else { return SeqNoDefaultValue; } }
      set {
        _hasBits0 |= 1;
        seqNo_ = value;
      }
    }
    /// <summary>Gets whether the "seq_no" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSeqNo {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "seq_no" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSeqNo() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "first_incomplete_seq_no" field.</summary>
    public const int FirstIncompleteSeqNoFieldNumber = 3;
    private readonly static long FirstIncompleteSeqNoDefaultValue = 0L;

    private long firstIncompleteSeqNo_;
    /// <summary>
    /// The sequence number of the first RPC that has not been marked as completed by the client.
    /// Unset if there isn't an incomplete RPC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long FirstIncompleteSeqNo {
      get { if ((_hasBits0 & 2) != 0) { return firstIncompleteSeqNo_; } else { return FirstIncompleteSeqNoDefaultValue; } }
      set {
        _hasBits0 |= 2;
        firstIncompleteSeqNo_ = value;
      }
    }
    /// <summary>Gets whether the "first_incomplete_seq_no" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFirstIncompleteSeqNo {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "first_incomplete_seq_no" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFirstIncompleteSeqNo() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "attempt_no" field.</summary>
    public const int AttemptNoFieldNumber = 4;
    private readonly static long AttemptNoDefaultValue = 0L;

    private long attemptNo_;
    /// <summary>
    /// The number of times this RPC has been tried.
    /// Set to 1 in the first attempt.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long AttemptNo {
      get { if ((_hasBits0 & 4) != 0) { return attemptNo_; } else { return AttemptNoDefaultValue; } }
      set {
        _hasBits0 |= 4;
        attemptNo_ = value;
      }
    }
    /// <summary>Gets whether the "attempt_no" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAttemptNo {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "attempt_no" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAttemptNo() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RequestIdPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RequestIdPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClientId != other.ClientId) return false;
      if (SeqNo != other.SeqNo) return false;
      if (FirstIncompleteSeqNo != other.FirstIncompleteSeqNo) return false;
      if (AttemptNo != other.AttemptNo) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasClientId) hash ^= ClientId.GetHashCode();
      if (HasSeqNo) hash ^= SeqNo.GetHashCode();
      if (HasFirstIncompleteSeqNo) hash ^= FirstIncompleteSeqNo.GetHashCode();
      if (HasAttemptNo) hash ^= AttemptNo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasClientId) {
        output.WriteRawTag(10);
        output.WriteString(ClientId);
      }
      if (HasSeqNo) {
        output.WriteRawTag(16);
        output.WriteInt64(SeqNo);
      }
      if (HasFirstIncompleteSeqNo) {
        output.WriteRawTag(24);
        output.WriteInt64(FirstIncompleteSeqNo);
      }
      if (HasAttemptNo) {
        output.WriteRawTag(32);
        output.WriteInt64(AttemptNo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasClientId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClientId);
      }
      if (HasSeqNo) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SeqNo);
      }
      if (HasFirstIncompleteSeqNo) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(FirstIncompleteSeqNo);
      }
      if (HasAttemptNo) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(AttemptNo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RequestIdPB other) {
      if (other == null) {
        return;
      }
      if (other.HasClientId) {
        ClientId = other.ClientId;
      }
      if (other.HasSeqNo) {
        SeqNo = other.SeqNo;
      }
      if (other.HasFirstIncompleteSeqNo) {
        FirstIncompleteSeqNo = other.FirstIncompleteSeqNo;
      }
      if (other.HasAttemptNo) {
        AttemptNo = other.AttemptNo;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ClientId = input.ReadString();
            break;
          }
          case 16: {
            SeqNo = input.ReadInt64();
            break;
          }
          case 24: {
            FirstIncompleteSeqNo = input.ReadInt64();
            break;
          }
          case 32: {
            AttemptNo = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The header for the RPC request frame.
  /// </summary>
  public sealed partial class RequestHeader : pb::IMessage<RequestHeader>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<RequestHeader> _parser = new pb::MessageParser<RequestHeader>(() => new RequestHeader());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RequestHeader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestHeader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestHeader(RequestHeader other) : this() {
      _hasBits0 = other._hasBits0;
      callId_ = other.callId_;
      remoteMethod_ = other.remoteMethod_ != null ? other.remoteMethod_.Clone() : null;
      timeoutMillis_ = other.timeoutMillis_;
      requiredFeatureFlags_ = other.requiredFeatureFlags_.Clone();
      requestId_ = other.requestId_ != null ? other.requestId_.Clone() : null;
      sidecarOffsets_ = other.sidecarOffsets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RequestHeader Clone() {
      return new RequestHeader(this);
    }

    /// <summary>Field number for the "call_id" field.</summary>
    public const int CallIdFieldNumber = 3;
    private readonly static int CallIdDefaultValue = 0;

    private int callId_;
    /// <summary>
    /// A sequence number that uniquely identifies a call to a single remote server. This number is
    /// sent back in the Response and allows to match it to the original Request.
    /// Hadoop specifies a uint32 and casts it to a signed int. That is counterintuitive, so we use an
    /// int32 instead. Allowed values (inherited from Hadoop):
    ///   0 through INT32_MAX: Regular RPC call IDs.
    ///   -2: Invalid call ID.
    ///   -3: Connection context call ID.
    ///   -33: SASL negotiation call ID.
    ///
    /// NOTE: these calls must be increasing but may have gaps.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CallId {
      get { if ((_hasBits0 & 1) != 0) { return callId_; } else { return CallIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        callId_ = value;
      }
    }
    /// <summary>Gets whether the "call_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCallId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "call_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCallId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "remote_method" field.</summary>
    public const int RemoteMethodFieldNumber = 6;
    private global::Knet.Kudu.Client.Protobuf.Rpc.RemoteMethodPB remoteMethod_;
    /// <summary>
    /// RPC method being invoked.
    /// Not used for "connection setup" calls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.RemoteMethodPB RemoteMethod {
      get { return remoteMethod_; }
      set {
        remoteMethod_ = value;
      }
    }

    /// <summary>Field number for the "timeout_millis" field.</summary>
    public const int TimeoutMillisFieldNumber = 10;
    private readonly static uint TimeoutMillisDefaultValue = 0;

    private uint timeoutMillis_;
    /// <summary>
    /// Propagate the timeout as specified by the user. Note that, since there is some
    /// transit time between the client and server, if you wait exactly this amount of
    /// time and then respond, you are likely to cause a timeout on the client.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TimeoutMillis {
      get { if ((_hasBits0 & 2) != 0) { return timeoutMillis_; } else { return TimeoutMillisDefaultValue; } }
      set {
        _hasBits0 |= 2;
        timeoutMillis_ = value;
      }
    }
    /// <summary>Gets whether the "timeout_millis" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTimeoutMillis {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "timeout_millis" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTimeoutMillis() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "required_feature_flags" field.</summary>
    public const int RequiredFeatureFlagsFieldNumber = 11;
    private static readonly pb::FieldCodec<uint> _repeated_requiredFeatureFlags_codec
        = pb::FieldCodec.ForUInt32(88);
    private readonly pbc::RepeatedField<uint> requiredFeatureFlags_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Feature flags that the service must support in order to properly interpret this
    /// request. The client can pass any set of flags, and if the server doesn't
    /// support any of them, then it will fail the request.
    ///
    /// NOTE: these are for evolving features at the level of the application, not
    /// the RPC framework. Hence, we have to use a generic int type rather than a
    /// particular enum.
    /// NOTE: the server will only interpret this field if it supports the
    /// APPLICATION_FEATURE_FLAGS flag.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> RequiredFeatureFlags {
      get { return requiredFeatureFlags_; }
    }

    /// <summary>Field number for the "request_id" field.</summary>
    public const int RequestIdFieldNumber = 15;
    private global::Knet.Kudu.Client.Protobuf.Rpc.RequestIdPB requestId_;
    /// <summary>
    /// The unique id of this request, if it's retriable and if the results are to be tracked.
    /// The request id is unique per logical request, i.e. retries of the same RPC must have the
    /// same request id.
    /// Note that this is different from 'call_id' in that a call_id is unique to a server while a
    /// request_id is unique to a logical request (i.e. the request_id remains the same when a request
    /// is retried on a different server).
    /// Optional for requests that are naturally idempotent or to maintain compatibility with
    /// older clients for requests that are not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.RequestIdPB RequestId {
      get { return requestId_; }
      set {
        requestId_ = value;
      }
    }

    /// <summary>Field number for the "sidecar_offsets" field.</summary>
    public const int SidecarOffsetsFieldNumber = 16;
    private static readonly pb::FieldCodec<uint> _repeated_sidecarOffsets_codec
        = pb::FieldCodec.ForUInt32(128);
    private readonly pbc::RepeatedField<uint> sidecarOffsets_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Byte offsets for side cars in the main body of the request message.
    /// These offsets are counted AFTER the message header, i.e., offset 0
    /// is the first byte after the bytes for this protobuf.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SidecarOffsets {
      get { return sidecarOffsets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RequestHeader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RequestHeader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CallId != other.CallId) return false;
      if (!object.Equals(RemoteMethod, other.RemoteMethod)) return false;
      if (TimeoutMillis != other.TimeoutMillis) return false;
      if(!requiredFeatureFlags_.Equals(other.requiredFeatureFlags_)) return false;
      if (!object.Equals(RequestId, other.RequestId)) return false;
      if(!sidecarOffsets_.Equals(other.sidecarOffsets_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCallId) hash ^= CallId.GetHashCode();
      if (remoteMethod_ != null) hash ^= RemoteMethod.GetHashCode();
      if (HasTimeoutMillis) hash ^= TimeoutMillis.GetHashCode();
      hash ^= requiredFeatureFlags_.GetHashCode();
      if (requestId_ != null) hash ^= RequestId.GetHashCode();
      hash ^= sidecarOffsets_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCallId) {
        output.WriteRawTag(24);
        output.WriteInt32(CallId);
      }
      if (remoteMethod_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RemoteMethod);
      }
      if (HasTimeoutMillis) {
        output.WriteRawTag(80);
        output.WriteUInt32(TimeoutMillis);
      }
      requiredFeatureFlags_.WriteTo(ref output, _repeated_requiredFeatureFlags_codec);
      if (requestId_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(RequestId);
      }
      sidecarOffsets_.WriteTo(ref output, _repeated_sidecarOffsets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasCallId) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CallId);
      }
      if (remoteMethod_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteMethod);
      }
      if (HasTimeoutMillis) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TimeoutMillis);
      }
      size += requiredFeatureFlags_.CalculateSize(_repeated_requiredFeatureFlags_codec);
      if (requestId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestId);
      }
      size += sidecarOffsets_.CalculateSize(_repeated_sidecarOffsets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RequestHeader other) {
      if (other == null) {
        return;
      }
      if (other.HasCallId) {
        CallId = other.CallId;
      }
      if (other.remoteMethod_ != null) {
        if (remoteMethod_ == null) {
          RemoteMethod = new global::Knet.Kudu.Client.Protobuf.Rpc.RemoteMethodPB();
        }
        RemoteMethod.MergeFrom(other.RemoteMethod);
      }
      if (other.HasTimeoutMillis) {
        TimeoutMillis = other.TimeoutMillis;
      }
      requiredFeatureFlags_.Add(other.requiredFeatureFlags_);
      if (other.requestId_ != null) {
        if (requestId_ == null) {
          RequestId = new global::Knet.Kudu.Client.Protobuf.Rpc.RequestIdPB();
        }
        RequestId.MergeFrom(other.RequestId);
      }
      sidecarOffsets_.Add(other.sidecarOffsets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 24: {
            CallId = input.ReadInt32();
            break;
          }
          case 50: {
            if (remoteMethod_ == null) {
              RemoteMethod = new global::Knet.Kudu.Client.Protobuf.Rpc.RemoteMethodPB();
            }
            input.ReadMessage(RemoteMethod);
            break;
          }
          case 80: {
            TimeoutMillis = input.ReadUInt32();
            break;
          }
          case 90:
          case 88: {
            requiredFeatureFlags_.AddEntriesFrom(ref input, _repeated_requiredFeatureFlags_codec);
            break;
          }
          case 122: {
            if (requestId_ == null) {
              RequestId = new global::Knet.Kudu.Client.Protobuf.Rpc.RequestIdPB();
            }
            input.ReadMessage(RequestId);
            break;
          }
          case 130:
          case 128: {
            sidecarOffsets_.AddEntriesFrom(ref input, _repeated_sidecarOffsets_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ResponseHeader : pb::IMessage<ResponseHeader>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<ResponseHeader> _parser = new pb::MessageParser<ResponseHeader>(() => new ResponseHeader());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ResponseHeader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResponseHeader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResponseHeader(ResponseHeader other) : this() {
      _hasBits0 = other._hasBits0;
      callId_ = other.callId_;
      isError_ = other.isError_;
      sidecarOffsets_ = other.sidecarOffsets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResponseHeader Clone() {
      return new ResponseHeader(this);
    }

    /// <summary>Field number for the "call_id" field.</summary>
    public const int CallIdFieldNumber = 1;
    private readonly static int CallIdDefaultValue = 0;

    private int callId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CallId {
      get { if ((_hasBits0 & 1) != 0) { return callId_; } else { return CallIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        callId_ = value;
      }
    }
    /// <summary>Gets whether the "call_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCallId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "call_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCallId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "is_error" field.</summary>
    public const int IsErrorFieldNumber = 2;
    private readonly static bool IsErrorDefaultValue = false;

    private bool isError_;
    /// <summary>
    /// If this is set, then this is an error response and the
    /// response message will be of type ErrorStatusPB instead of
    /// the expected response type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsError {
      get { if ((_hasBits0 & 2) != 0) { return isError_; } else { return IsErrorDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isError_ = value;
      }
    }
    /// <summary>Gets whether the "is_error" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsError {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_error" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsError() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sidecar_offsets" field.</summary>
    public const int SidecarOffsetsFieldNumber = 3;
    private static readonly pb::FieldCodec<uint> _repeated_sidecarOffsets_codec
        = pb::FieldCodec.ForUInt32(24);
    private readonly pbc::RepeatedField<uint> sidecarOffsets_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Byte offsets for side cars in the main body of the response message.
    /// These offsets are counted AFTER the message header, i.e., offset 0
    /// is the first byte after the bytes for this protobuf.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SidecarOffsets {
      get { return sidecarOffsets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ResponseHeader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ResponseHeader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CallId != other.CallId) return false;
      if (IsError != other.IsError) return false;
      if(!sidecarOffsets_.Equals(other.sidecarOffsets_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCallId) hash ^= CallId.GetHashCode();
      if (HasIsError) hash ^= IsError.GetHashCode();
      hash ^= sidecarOffsets_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCallId) {
        output.WriteRawTag(8);
        output.WriteInt32(CallId);
      }
      if (HasIsError) {
        output.WriteRawTag(16);
        output.WriteBool(IsError);
      }
      sidecarOffsets_.WriteTo(ref output, _repeated_sidecarOffsets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasCallId) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CallId);
      }
      if (HasIsError) {
        size += 1 + 1;
      }
      size += sidecarOffsets_.CalculateSize(_repeated_sidecarOffsets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ResponseHeader other) {
      if (other == null) {
        return;
      }
      if (other.HasCallId) {
        CallId = other.CallId;
      }
      if (other.HasIsError) {
        IsError = other.IsError;
      }
      sidecarOffsets_.Add(other.sidecarOffsets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CallId = input.ReadInt32();
            break;
          }
          case 16: {
            IsError = input.ReadBool();
            break;
          }
          case 26:
          case 24: {
            sidecarOffsets_.AddEntriesFrom(ref input, _repeated_sidecarOffsets_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Sent as response when is_error == true.
  /// </summary>
  public sealed partial class ErrorStatusPB : pb::IExtendableMessage<ErrorStatusPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<ErrorStatusPB> _parser = new pb::MessageParser<ErrorStatusPB>(() => new ErrorStatusPB());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<ErrorStatusPB> _extensions;
    private pb::ExtensionSet<ErrorStatusPB> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ErrorStatusPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Rpc.RpcHeaderReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorStatusPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorStatusPB(ErrorStatusPB other) : this() {
      _hasBits0 = other._hasBits0;
      message_ = other.message_;
      code_ = other.code_;
      unsupportedFeatureFlags_ = other.unsupportedFeatureFlags_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ErrorStatusPB Clone() {
      return new ErrorStatusPB(this);
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 1;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 2;
    private readonly static global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Types.RpcErrorCodePB CodeDefaultValue = global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Types.RpcErrorCodePB.FatalUnknown;

    private global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Types.RpcErrorCodePB code_;
    /// <summary>
    /// TODO: Make code required?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Types.RpcErrorCodePB Code {
      get { if ((_hasBits0 & 1) != 0) { return code_; } else { return CodeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        code_ = value;
      }
    }
    /// <summary>Gets whether the "code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCode() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "unsupported_feature_flags" field.</summary>
    public const int UnsupportedFeatureFlagsFieldNumber = 3;
    private static readonly pb::FieldCodec<uint> _repeated_unsupportedFeatureFlags_codec
        = pb::FieldCodec.ForUInt32(24);
    private readonly pbc::RepeatedField<uint> unsupportedFeatureFlags_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// If the request is failed due to an unsupported feature flag, the particular
    /// flag(s) that were not supported will be sent back to the client.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> UnsupportedFeatureFlags {
      get { return unsupportedFeatureFlags_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ErrorStatusPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ErrorStatusPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Message != other.Message) return false;
      if (Code != other.Code) return false;
      if(!unsupportedFeatureFlags_.Equals(other.unsupportedFeatureFlags_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasCode) hash ^= Code.GetHashCode();
      hash ^= unsupportedFeatureFlags_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMessage) {
        output.WriteRawTag(10);
        output.WriteString(Message);
      }
      if (HasCode) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Code);
      }
      unsupportedFeatureFlags_.WriteTo(ref output, _repeated_unsupportedFeatureFlags_codec);
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasCode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Code);
      }
      size += unsupportedFeatureFlags_.CalculateSize(_repeated_unsupportedFeatureFlags_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ErrorStatusPB other) {
      if (other == null) {
        return;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasCode) {
        Code = other.Code;
      }
      unsupportedFeatureFlags_.Add(other.unsupportedFeatureFlags_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            Message = input.ReadString();
            break;
          }
          case 16: {
            Code = (global::Knet.Kudu.Client.Protobuf.Rpc.ErrorStatusPB.Types.RpcErrorCodePB) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            unsupportedFeatureFlags_.AddEntriesFrom(ref input, _repeated_unsupportedFeatureFlags_codec);
            break;
          }
        }
      }
    }

    public TValue GetExtension<TValue>(pb::Extension<ErrorStatusPB, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<ErrorStatusPB, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<ErrorStatusPB, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<ErrorStatusPB, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<ErrorStatusPB, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<ErrorStatusPB, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<ErrorStatusPB, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ErrorStatusPB message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// These codes have all been inherited from Hadoop's RPC mechanism.
      /// </summary>
      public enum RpcErrorCodePB {
        [pbr::OriginalName("FATAL_UNKNOWN")] FatalUnknown = 10,
        /// <summary>
        /// Non-fatal RPC errors. Connection should be left open for future RPC calls.
        ///------------------------------------------------------------
        /// The application generated an error status. See the message field for
        /// more details.
        /// </summary>
        [pbr::OriginalName("ERROR_APPLICATION")] ErrorApplication = 1,
        /// <summary>
        /// The specified method was not valid.
        /// </summary>
        [pbr::OriginalName("ERROR_NO_SUCH_METHOD")] ErrorNoSuchMethod = 2,
        /// <summary>
        /// The specified service was not valid.
        /// </summary>
        [pbr::OriginalName("ERROR_NO_SUCH_SERVICE")] ErrorNoSuchService = 3,
        /// <summary>
        /// The server is overloaded - the client should try again shortly.
        /// </summary>
        [pbr::OriginalName("ERROR_SERVER_TOO_BUSY")] ErrorServerTooBusy = 4,
        /// <summary>
        /// The request parameter was not parseable, was missing required fields,
        /// or the server does not support the required feature flags.
        /// </summary>
        [pbr::OriginalName("ERROR_INVALID_REQUEST")] ErrorInvalidRequest = 5,
        /// <summary>
        /// The server might have previously received this request but its response is no
        /// longer cached. It's unknown whether the request was executed or not.
        /// </summary>
        [pbr::OriginalName("ERROR_REQUEST_STALE")] ErrorRequestStale = 6,
        /// <summary>
        /// The server is not able to complete the connection or request at this
        /// time. The client may try again later.
        /// </summary>
        [pbr::OriginalName("ERROR_UNAVAILABLE")] ErrorUnavailable = 7,
        /// <summary>
        /// The authorization token is invalid or expired. Unlike
        /// FATAL_INVALID_AUTHENTICATION_TOKEN, receipt of this code does not mean
        /// that a reconnection attempt should be made; just that the client should
        /// obtain a new authz token.
        /// </summary>
        [pbr::OriginalName("ERROR_INVALID_AUTHORIZATION_TOKEN")] ErrorInvalidAuthorizationToken = 17,
        /// <summary>
        /// FATAL_* errors indicate that the client should shut down the connection.
        ///------------------------------------------------------------
        /// The RPC server is already shutting down.
        /// </summary>
        [pbr::OriginalName("FATAL_SERVER_SHUTTING_DOWN")] FatalServerShuttingDown = 11,
        /// <summary>
        /// Fields of RpcHeader are invalid.
        /// </summary>
        [pbr::OriginalName("FATAL_INVALID_RPC_HEADER")] FatalInvalidRpcHeader = 12,
        /// <summary>
        /// Could not deserialize RPC request.
        /// </summary>
        [pbr::OriginalName("FATAL_DESERIALIZING_REQUEST")] FatalDeserializingRequest = 13,
        /// <summary>
        /// IPC Layer version mismatch.
        /// </summary>
        [pbr::OriginalName("FATAL_VERSION_MISMATCH")] FatalVersionMismatch = 14,
        /// <summary>
        /// Auth failed.
        /// </summary>
        [pbr::OriginalName("FATAL_UNAUTHORIZED")] FatalUnauthorized = 15,
        /// <summary>
        /// The authentication token is invalid or expired. The connection
        /// negotiation failed, and the client should obtain a new authn token and
        /// try to reconnect.
        /// </summary>
        [pbr::OriginalName("FATAL_INVALID_AUTHENTICATION_TOKEN")] FatalInvalidAuthenticationToken = 16,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
