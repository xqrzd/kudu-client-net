// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: kudu/client/client.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Knet.Kudu.Client.Protobuf.Client {

  /// <summary>Holder for reflection information generated from kudu/client/client.proto</summary>
  public static partial class ClientReflection {

    #region Descriptor
    /// <summary>File descriptor for kudu/client/client.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ClientReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChhrdWR1L2NsaWVudC9jbGllbnQucHJvdG8SC2t1ZHUuY2xpZW50GhhrdWR1",
            "L2NvbW1vbi9jb21tb24ucHJvdG8aHWt1ZHUvY29uc2Vuc3VzL21ldGFkYXRh",
            "LnByb3RvGhlrdWR1L3NlY3VyaXR5L3Rva2VuLnByb3RvGhdrdWR1L3V0aWwv",
            "cGJfdXRpbC5wcm90byK8AgoPVGFibGVNZXRhZGF0YVBCEhAKCHRhYmxlX2lk",
            "GAEgASgJEhIKCnRhYmxlX25hbWUYAiABKAkSFAoMbnVtX3JlcGxpY2FzGAMg",
            "ASgFEh4KBnNjaGVtYRgEIAEoCzIOLmt1ZHUuU2NoZW1hUEISMQoQcGFydGl0",
            "aW9uX3NjaGVtYRgFIAEoCzIXLmt1ZHUuUGFydGl0aW9uU2NoZW1hUEISRQoN",
            "ZXh0cmFfY29uZmlncxgGIAMoCzIuLmt1ZHUuY2xpZW50LlRhYmxlTWV0YWRh",
            "dGFQQi5FeHRyYUNvbmZpZ3NFbnRyeRINCgVvd25lchgHIAEoCRIPCgdjb21t",
            "ZW50GAggASgJGjMKEUV4dHJhQ29uZmlnc0VudHJ5EgsKA2tleRgBIAEoCRIN",
            "CgV2YWx1ZRgCIAEoCToCOAEiWwoQU2VydmVyTWV0YWRhdGFQQhIMCgR1dWlk",
            "GAEgASgMEicKDXJwY19hZGRyZXNzZXMYAiADKAsyEC5rdWR1Lkhvc3RQb3J0",
            "UEISEAoIbG9jYXRpb24YAyABKAkixgIKEFRhYmxldE1ldGFkYXRhUEISEQoJ",
            "dGFibGV0X2lkGAEgASgJEiQKCXBhcnRpdGlvbhgCIAEoCzIRLmt1ZHUuUGFy",
            "dGl0aW9uUEISNQoOdGFibGV0X3NlcnZlcnMYAyADKAsyHS5rdWR1LmNsaWVu",
            "dC5TZXJ2ZXJNZXRhZGF0YVBCEkEKCHJlcGxpY2FzGAQgAygLMi8ua3VkdS5j",
            "bGllbnQuVGFibGV0TWV0YWRhdGFQQi5SZXBsaWNhTWV0YWRhdGFQQhISCgp0",
            "dGxfbWlsbGlzGAUgASgEGmsKEVJlcGxpY2FNZXRhZGF0YVBCEg4KBnRzX2lk",
            "eBgBIAIoDRItCgRyb2xlGAIgAigOMh8ua3VkdS5jb25zZW5zdXMuUmFmdFBl",
            "ZXJQQi5Sb2xlEhcKD2RpbWVuc2lvbl9sYWJlbBgDIAEoCSKzBwoLU2NhblRv",
            "a2VuUEISNwoNZmVhdHVyZV9mbGFncxgBIAMoDjIgLmt1ZHUuY2xpZW50LlNj",
            "YW5Ub2tlblBCLkZlYXR1cmUSEAoIdGFibGVfaWQYFCABKAkSEgoKdGFibGVf",
            "bmFtZRgCIAEoCRI0Cg50YWJsZV9tZXRhZGF0YRgVIAEoCzIcLmt1ZHUuY2xp",
            "ZW50LlRhYmxlTWV0YWRhdGFQQhI2Cg90YWJsZXRfbWV0YWRhdGEYFiABKAsy",
            "HS5rdWR1LmNsaWVudC5UYWJsZXRNZXRhZGF0YVBCEhwKFHByb2plY3RlZF9j",
            "b2x1bW5faWR4GBcgAygFEi8KEXByb2plY3RlZF9jb2x1bW5zGAMgAygLMhQu",
            "a3VkdS5Db2x1bW5TY2hlbWFQQhIyChFjb2x1bW5fcHJlZGljYXRlcxgEIAMo",
            "CzIXLmt1ZHUuQ29sdW1uUHJlZGljYXRlUEISJQoXbG93ZXJfYm91bmRfcHJp",
            "bWFyeV9rZXkYBSABKAxCBIi1GAESJQoXdXBwZXJfYm91bmRfcHJpbWFyeV9r",
            "ZXkYBiABKAxCBIi1GAESJwoZbG93ZXJfYm91bmRfcGFydGl0aW9uX2tleRgH",
            "IAEoDEIEiLUYARInChl1cHBlcl9ib3VuZF9wYXJ0aXRpb25fa2V5GAggASgM",
            "QgSItRgBEg0KBWxpbWl0GAkgASgEEjAKCXJlYWRfbW9kZRgKIAEoDjIQLmt1",
            "ZHUuUmVhZE1vZGVQQjoLUkVBRF9MQVRFU1QSFgoOc25hcF90aW1lc3RhbXAY",
            "CyABKAYSHAoUc25hcF9zdGFydF90aW1lc3RhbXAYEyABKAYSHAoUcHJvcGFn",
            "YXRlZF90aW1lc3RhbXAYDCABKAYSGgoMY2FjaGVfYmxvY2tzGA0gASgIOgR0",
            "cnVlEh0KDmZhdWx0X3RvbGVyYW50GA4gASgIOgVmYWxzZRIYChBiYXRjaF9z",
            "aXplX2J5dGVzGA8gASgNEkAKEXJlcGxpY2Ffc2VsZWN0aW9uGBAgASgOMhgu",
            "a3VkdS5SZXBsaWNhU2VsZWN0aW9uUEI6C0xFQURFUl9PTkxZEh8KF3NjYW5f",
            "cmVxdWVzdF90aW1lb3V0X21zGBEgASgDEhwKFGtlZXBfYWxpdmVfcGVyaW9k",
            "X21zGBIgASgDEjEKC2F1dGh6X3Rva2VuGBggASgLMhwua3VkdS5zZWN1cml0",
            "eS5TaWduZWRUb2tlblBCIhYKB0ZlYXR1cmUSCwoHVW5rbm93bhAAInkKG0F1",
            "dGhlbnRpY2F0aW9uQ3JlZGVudGlhbHNQQhIxCgthdXRobl90b2tlbhgBIAEo",
            "CzIcLmt1ZHUuc2VjdXJpdHkuU2lnbmVkVG9rZW5QQhIRCglyZWFsX3VzZXIY",
            "AyABKAkSFAoMY2FfY2VydF9kZXJzGAIgAygMQjsKFm9yZy5hcGFjaGUua3Vk",
            "dS5jbGllbnSqAiBLbmV0Lkt1ZHUuQ2xpZW50LlByb3RvYnVmLkNsaWVudA=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Knet.Kudu.Client.Protobuf.CommonReflection.Descriptor, global::Knet.Kudu.Client.Protobuf.Consensus.MetadataReflection.Descriptor, global::Knet.Kudu.Client.Protobuf.Security.TokenReflection.Descriptor, global::Knet.Kudu.Client.Protobuf.PbUtilReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Client.TableMetadataPB), global::Knet.Kudu.Client.Protobuf.Client.TableMetadataPB.Parser, new[]{ "TableId", "TableName", "NumReplicas", "Schema", "PartitionSchema", "ExtraConfigs", "Owner", "Comment" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB), global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB.Parser, new[]{ "Uuid", "RpcAddresses", "Location" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB), global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Parser, new[]{ "TabletId", "Partition", "TabletServers", "Replicas", "TtlMillis" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB), global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB.Parser, new[]{ "TsIdx", "Role", "DimensionLabel" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB), global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Parser, new[]{ "FeatureFlags", "TableId", "TableName", "TableMetadata", "TabletMetadata", "ProjectedColumnIdx", "ProjectedColumns", "ColumnPredicates", "LowerBoundPrimaryKey", "UpperBoundPrimaryKey", "LowerBoundPartitionKey", "UpperBoundPartitionKey", "Limit", "ReadMode", "SnapTimestamp", "SnapStartTimestamp", "PropagatedTimestamp", "CacheBlocks", "FaultTolerant", "BatchSizeBytes", "ReplicaSelection", "ScanRequestTimeoutMs", "KeepAlivePeriodMs", "AuthzToken" }, null, new[]{ typeof(global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Types.Feature) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Knet.Kudu.Client.Protobuf.Client.AuthenticationCredentialsPB), global::Knet.Kudu.Client.Protobuf.Client.AuthenticationCredentialsPB.Parser, new[]{ "AuthnToken", "RealUser", "CaCertDers" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// All of the metadata required to create a KuduTable object in the C++
  /// and Java clients.
  /// TODO(KUDU-3135): Use for generic metadata tokens outside of the scan token.
  /// </summary>
  public sealed partial class TableMetadataPB : pb::IMessage<TableMetadataPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<TableMetadataPB> _parser = new pb::MessageParser<TableMetadataPB>(() => new TableMetadataPB());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TableMetadataPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Client.ClientReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TableMetadataPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TableMetadataPB(TableMetadataPB other) : this() {
      _hasBits0 = other._hasBits0;
      tableId_ = other.tableId_;
      tableName_ = other.tableName_;
      numReplicas_ = other.numReplicas_;
      schema_ = other.schema_ != null ? other.schema_.Clone() : null;
      partitionSchema_ = other.partitionSchema_ != null ? other.partitionSchema_.Clone() : null;
      extraConfigs_ = other.extraConfigs_.Clone();
      owner_ = other.owner_;
      comment_ = other.comment_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TableMetadataPB Clone() {
      return new TableMetadataPB(this);
    }

    /// <summary>Field number for the "table_id" field.</summary>
    public const int TableIdFieldNumber = 1;
    private readonly static string TableIdDefaultValue = "";

    private string tableId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TableId {
      get { return tableId_ ?? TableIdDefaultValue; }
      set {
        tableId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "table_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTableId {
      get { return tableId_ != null; }
    }
    /// <summary>Clears the value of the "table_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTableId() {
      tableId_ = null;
    }

    /// <summary>Field number for the "table_name" field.</summary>
    public const int TableNameFieldNumber = 2;
    private readonly static string TableNameDefaultValue = "";

    private string tableName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TableName {
      get { return tableName_ ?? TableNameDefaultValue; }
      set {
        tableName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "table_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTableName {
      get { return tableName_ != null; }
    }
    /// <summary>Clears the value of the "table_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTableName() {
      tableName_ = null;
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 3;
    private readonly static int NumReplicasDefaultValue = 0;

    private int numReplicas_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { if ((_hasBits0 & 1) != 0) { return numReplicas_; } else { return NumReplicasDefaultValue; } }
      set {
        _hasBits0 |= 1;
        numReplicas_ = value;
      }
    }
    /// <summary>Gets whether the "num_replicas" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumReplicas {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "num_replicas" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumReplicas() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "schema" field.</summary>
    public const int SchemaFieldNumber = 4;
    private global::Knet.Kudu.Client.Protobuf.SchemaPB schema_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.SchemaPB Schema {
      get { return schema_; }
      set {
        schema_ = value;
      }
    }

    /// <summary>Field number for the "partition_schema" field.</summary>
    public const int PartitionSchemaFieldNumber = 5;
    private global::Knet.Kudu.Client.Protobuf.PartitionSchemaPB partitionSchema_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.PartitionSchemaPB PartitionSchema {
      get { return partitionSchema_; }
      set {
        partitionSchema_ = value;
      }
    }

    /// <summary>Field number for the "extra_configs" field.</summary>
    public const int ExtraConfigsFieldNumber = 6;
    private static readonly pbc::MapField<string, string>.Codec _map_extraConfigs_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 50);
    private readonly pbc::MapField<string, string> extraConfigs_ = new pbc::MapField<string, string>();
    /// <summary>
    /// The table's extra configuration properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> ExtraConfigs {
      get { return extraConfigs_; }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 7;
    private readonly static string OwnerDefaultValue = "";

    private string owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Owner {
      get { return owner_ ?? OwnerDefaultValue; }
      set {
        owner_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "owner" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOwner {
      get { return owner_ != null; }
    }
    /// <summary>Clears the value of the "owner" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOwner() {
      owner_ = null;
    }

    /// <summary>Field number for the "comment" field.</summary>
    public const int CommentFieldNumber = 8;
    private readonly static string CommentDefaultValue = "";

    private string comment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Comment {
      get { return comment_ ?? CommentDefaultValue; }
      set {
        comment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "comment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasComment {
      get { return comment_ != null; }
    }
    /// <summary>Clears the value of the "comment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearComment() {
      comment_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TableMetadataPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TableMetadataPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TableId != other.TableId) return false;
      if (TableName != other.TableName) return false;
      if (NumReplicas != other.NumReplicas) return false;
      if (!object.Equals(Schema, other.Schema)) return false;
      if (!object.Equals(PartitionSchema, other.PartitionSchema)) return false;
      if (!ExtraConfigs.Equals(other.ExtraConfigs)) return false;
      if (Owner != other.Owner) return false;
      if (Comment != other.Comment) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTableId) hash ^= TableId.GetHashCode();
      if (HasTableName) hash ^= TableName.GetHashCode();
      if (HasNumReplicas) hash ^= NumReplicas.GetHashCode();
      if (schema_ != null) hash ^= Schema.GetHashCode();
      if (partitionSchema_ != null) hash ^= PartitionSchema.GetHashCode();
      hash ^= ExtraConfigs.GetHashCode();
      if (HasOwner) hash ^= Owner.GetHashCode();
      if (HasComment) hash ^= Comment.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTableId) {
        output.WriteRawTag(10);
        output.WriteString(TableId);
      }
      if (HasTableName) {
        output.WriteRawTag(18);
        output.WriteString(TableName);
      }
      if (HasNumReplicas) {
        output.WriteRawTag(24);
        output.WriteInt32(NumReplicas);
      }
      if (schema_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Schema);
      }
      if (partitionSchema_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(PartitionSchema);
      }
      extraConfigs_.WriteTo(ref output, _map_extraConfigs_codec);
      if (HasOwner) {
        output.WriteRawTag(58);
        output.WriteString(Owner);
      }
      if (HasComment) {
        output.WriteRawTag(66);
        output.WriteString(Comment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasTableId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TableId);
      }
      if (HasTableName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TableName);
      }
      if (HasNumReplicas) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      if (schema_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Schema);
      }
      if (partitionSchema_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PartitionSchema);
      }
      size += extraConfigs_.CalculateSize(_map_extraConfigs_codec);
      if (HasOwner) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Owner);
      }
      if (HasComment) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Comment);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TableMetadataPB other) {
      if (other == null) {
        return;
      }
      if (other.HasTableId) {
        TableId = other.TableId;
      }
      if (other.HasTableName) {
        TableName = other.TableName;
      }
      if (other.HasNumReplicas) {
        NumReplicas = other.NumReplicas;
      }
      if (other.schema_ != null) {
        if (schema_ == null) {
          Schema = new global::Knet.Kudu.Client.Protobuf.SchemaPB();
        }
        Schema.MergeFrom(other.Schema);
      }
      if (other.partitionSchema_ != null) {
        if (partitionSchema_ == null) {
          PartitionSchema = new global::Knet.Kudu.Client.Protobuf.PartitionSchemaPB();
        }
        PartitionSchema.MergeFrom(other.PartitionSchema);
      }
      extraConfigs_.Add(other.extraConfigs_);
      if (other.HasOwner) {
        Owner = other.Owner;
      }
      if (other.HasComment) {
        Comment = other.Comment;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TableId = input.ReadString();
            break;
          }
          case 18: {
            TableName = input.ReadString();
            break;
          }
          case 24: {
            NumReplicas = input.ReadInt32();
            break;
          }
          case 34: {
            if (schema_ == null) {
              Schema = new global::Knet.Kudu.Client.Protobuf.SchemaPB();
            }
            input.ReadMessage(Schema);
            break;
          }
          case 42: {
            if (partitionSchema_ == null) {
              PartitionSchema = new global::Knet.Kudu.Client.Protobuf.PartitionSchemaPB();
            }
            input.ReadMessage(PartitionSchema);
            break;
          }
          case 50: {
            extraConfigs_.AddEntriesFrom(ref input, _map_extraConfigs_codec);
            break;
          }
          case 58: {
            Owner = input.ReadString();
            break;
          }
          case 66: {
            Comment = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Metdata about a single server.
  /// This can be used on the client to update the local cache of where
  /// each server is located.
  /// </summary>
  public sealed partial class ServerMetadataPB : pb::IMessage<ServerMetadataPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<ServerMetadataPB> _parser = new pb::MessageParser<ServerMetadataPB>(() => new ServerMetadataPB());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ServerMetadataPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Client.ClientReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServerMetadataPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServerMetadataPB(ServerMetadataPB other) : this() {
      uuid_ = other.uuid_;
      rpcAddresses_ = other.rpcAddresses_.Clone();
      location_ = other.location_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServerMetadataPB Clone() {
      return new ServerMetadataPB(this);
    }

    /// <summary>Field number for the "uuid" field.</summary>
    public const int UuidFieldNumber = 1;
    private readonly static pb::ByteString UuidDefaultValue = pb::ByteString.Empty;

    private pb::ByteString uuid_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Uuid {
      get { return uuid_ ?? UuidDefaultValue; }
      set {
        uuid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "uuid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUuid {
      get { return uuid_ != null; }
    }
    /// <summary>Clears the value of the "uuid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUuid() {
      uuid_ = null;
    }

    /// <summary>Field number for the "rpc_addresses" field.</summary>
    public const int RpcAddressesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.HostPortPB> _repeated_rpcAddresses_codec
        = pb::FieldCodec.ForMessage(18, global::Knet.Kudu.Client.Protobuf.HostPortPB.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.HostPortPB> rpcAddresses_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.HostPortPB>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.HostPortPB> RpcAddresses {
      get { return rpcAddresses_; }
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 3;
    private readonly static string LocationDefaultValue = "";

    private string location_;
    /// <summary>
    /// The location assignment for this server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Location {
      get { return location_ ?? LocationDefaultValue; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "location" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLocation {
      get { return location_ != null; }
    }
    /// <summary>Clears the value of the "location" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLocation() {
      location_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ServerMetadataPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ServerMetadataPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uuid != other.Uuid) return false;
      if(!rpcAddresses_.Equals(other.rpcAddresses_)) return false;
      if (Location != other.Location) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUuid) hash ^= Uuid.GetHashCode();
      hash ^= rpcAddresses_.GetHashCode();
      if (HasLocation) hash ^= Location.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUuid) {
        output.WriteRawTag(10);
        output.WriteBytes(Uuid);
      }
      rpcAddresses_.WriteTo(ref output, _repeated_rpcAddresses_codec);
      if (HasLocation) {
        output.WriteRawTag(26);
        output.WriteString(Location);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasUuid) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Uuid);
      }
      size += rpcAddresses_.CalculateSize(_repeated_rpcAddresses_codec);
      if (HasLocation) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Location);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ServerMetadataPB other) {
      if (other == null) {
        return;
      }
      if (other.HasUuid) {
        Uuid = other.Uuid;
      }
      rpcAddresses_.Add(other.rpcAddresses_);
      if (other.HasLocation) {
        Location = other.Location;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Uuid = input.ReadBytes();
            break;
          }
          case 18: {
            rpcAddresses_.AddEntriesFrom(ref input, _repeated_rpcAddresses_codec);
            break;
          }
          case 26: {
            Location = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// All of the metadata required to create a RemoteTablet object in the C++
  /// and Java clients.
  /// </summary>
  public sealed partial class TabletMetadataPB : pb::IMessage<TabletMetadataPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<TabletMetadataPB> _parser = new pb::MessageParser<TabletMetadataPB>(() => new TabletMetadataPB());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TabletMetadataPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Client.ClientReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TabletMetadataPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TabletMetadataPB(TabletMetadataPB other) : this() {
      _hasBits0 = other._hasBits0;
      tabletId_ = other.tabletId_;
      partition_ = other.partition_ != null ? other.partition_.Clone() : null;
      tabletServers_ = other.tabletServers_.Clone();
      replicas_ = other.replicas_.Clone();
      ttlMillis_ = other.ttlMillis_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TabletMetadataPB Clone() {
      return new TabletMetadataPB(this);
    }

    /// <summary>Field number for the "tablet_id" field.</summary>
    public const int TabletIdFieldNumber = 1;
    private readonly static string TabletIdDefaultValue = "";

    private string tabletId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TabletId {
      get { return tabletId_ ?? TabletIdDefaultValue; }
      set {
        tabletId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "tablet_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTabletId {
      get { return tabletId_ != null; }
    }
    /// <summary>Clears the value of the "tablet_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTabletId() {
      tabletId_ = null;
    }

    /// <summary>Field number for the "partition" field.</summary>
    public const int PartitionFieldNumber = 2;
    private global::Knet.Kudu.Client.Protobuf.PartitionPB partition_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.PartitionPB Partition {
      get { return partition_; }
      set {
        partition_ = value;
      }
    }

    /// <summary>Field number for the "tablet_servers" field.</summary>
    public const int TabletServersFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB> _repeated_tabletServers_codec
        = pb::FieldCodec.ForMessage(26, global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB> tabletServers_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB>();
    /// <summary>
    /// The servers that host the replicas.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.ServerMetadataPB> TabletServers {
      get { return tabletServers_; }
    }

    /// <summary>Field number for the "replicas" field.</summary>
    public const int ReplicasFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB> _repeated_replicas_codec
        = pb::FieldCodec.ForMessage(34, global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB> replicas_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Types.ReplicaMetadataPB> Replicas {
      get { return replicas_; }
    }

    /// <summary>Field number for the "ttl_millis" field.</summary>
    public const int TtlMillisFieldNumber = 5;
    private readonly static ulong TtlMillisDefaultValue = 0UL;

    private ulong ttlMillis_;
    /// <summary>
    /// Cached table locations should not live longer than this timeout.
    /// Note: Some time will pass between serializing and deserializing
    /// the token. This means that that effective TTL would be longer
    /// than initially set. This shouldn't be a problem in normal usage
    /// given the time shouldn't be an extended period. Additionally,
    /// the client can retry if any failures occur due to outdated metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong TtlMillis {
      get { if ((_hasBits0 & 1) != 0) { return ttlMillis_; } else { return TtlMillisDefaultValue; } }
      set {
        _hasBits0 |= 1;
        ttlMillis_ = value;
      }
    }
    /// <summary>Gets whether the "ttl_millis" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTtlMillis {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "ttl_millis" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTtlMillis() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TabletMetadataPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TabletMetadataPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TabletId != other.TabletId) return false;
      if (!object.Equals(Partition, other.Partition)) return false;
      if(!tabletServers_.Equals(other.tabletServers_)) return false;
      if(!replicas_.Equals(other.replicas_)) return false;
      if (TtlMillis != other.TtlMillis) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTabletId) hash ^= TabletId.GetHashCode();
      if (partition_ != null) hash ^= Partition.GetHashCode();
      hash ^= tabletServers_.GetHashCode();
      hash ^= replicas_.GetHashCode();
      if (HasTtlMillis) hash ^= TtlMillis.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTabletId) {
        output.WriteRawTag(10);
        output.WriteString(TabletId);
      }
      if (partition_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Partition);
      }
      tabletServers_.WriteTo(ref output, _repeated_tabletServers_codec);
      replicas_.WriteTo(ref output, _repeated_replicas_codec);
      if (HasTtlMillis) {
        output.WriteRawTag(40);
        output.WriteUInt64(TtlMillis);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasTabletId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TabletId);
      }
      if (partition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Partition);
      }
      size += tabletServers_.CalculateSize(_repeated_tabletServers_codec);
      size += replicas_.CalculateSize(_repeated_replicas_codec);
      if (HasTtlMillis) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TtlMillis);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TabletMetadataPB other) {
      if (other == null) {
        return;
      }
      if (other.HasTabletId) {
        TabletId = other.TabletId;
      }
      if (other.partition_ != null) {
        if (partition_ == null) {
          Partition = new global::Knet.Kudu.Client.Protobuf.PartitionPB();
        }
        Partition.MergeFrom(other.Partition);
      }
      tabletServers_.Add(other.tabletServers_);
      replicas_.Add(other.replicas_);
      if (other.HasTtlMillis) {
        TtlMillis = other.TtlMillis;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TabletId = input.ReadString();
            break;
          }
          case 18: {
            if (partition_ == null) {
              Partition = new global::Knet.Kudu.Client.Protobuf.PartitionPB();
            }
            input.ReadMessage(Partition);
            break;
          }
          case 26: {
            tabletServers_.AddEntriesFrom(ref input, _repeated_tabletServers_codec);
            break;
          }
          case 34: {
            replicas_.AddEntriesFrom(ref input, _repeated_replicas_codec);
            break;
          }
          case 40: {
            TtlMillis = input.ReadUInt64();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TabletMetadataPB message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class ReplicaMetadataPB : pb::IMessage<ReplicaMetadataPB>
          , pb::IBufferMessage
      {
        private static readonly pb::MessageParser<ReplicaMetadataPB> _parser = new pb::MessageParser<ReplicaMetadataPB>(() => new ReplicaMetadataPB());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ReplicaMetadataPB> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReplicaMetadataPB() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReplicaMetadataPB(ReplicaMetadataPB other) : this() {
          _hasBits0 = other._hasBits0;
          tsIdx_ = other.tsIdx_;
          role_ = other.role_;
          dimensionLabel_ = other.dimensionLabel_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ReplicaMetadataPB Clone() {
          return new ReplicaMetadataPB(this);
        }

        /// <summary>Field number for the "ts_idx" field.</summary>
        public const int TsIdxFieldNumber = 1;
        private readonly static uint TsIdxDefaultValue = 0;

        private uint tsIdx_;
        /// <summary>
        /// The index of the tablet server in tablet_servers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint TsIdx {
          get { if ((_hasBits0 & 1) != 0) { return tsIdx_; } else { return TsIdxDefaultValue; } }
          set {
            _hasBits0 |= 1;
            tsIdx_ = value;
          }
        }
        /// <summary>Gets whether the "ts_idx" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTsIdx {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "ts_idx" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTsIdx() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "role" field.</summary>
        public const int RoleFieldNumber = 2;
        private readonly static global::Knet.Kudu.Client.Protobuf.Consensus.RaftPeerPB.Types.Role RoleDefaultValue = global::Knet.Kudu.Client.Protobuf.Consensus.RaftPeerPB.Types.Role.UnknownRole;

        private global::Knet.Kudu.Client.Protobuf.Consensus.RaftPeerPB.Types.Role role_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Knet.Kudu.Client.Protobuf.Consensus.RaftPeerPB.Types.Role Role {
          get { if ((_hasBits0 & 2) != 0) { return role_; } else { return RoleDefaultValue; } }
          set {
            _hasBits0 |= 2;
            role_ = value;
          }
        }
        /// <summary>Gets whether the "role" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasRole {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "role" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearRole() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "dimension_label" field.</summary>
        public const int DimensionLabelFieldNumber = 3;
        private readonly static string DimensionLabelDefaultValue = "";

        private string dimensionLabel_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string DimensionLabel {
          get { return dimensionLabel_ ?? DimensionLabelDefaultValue; }
          set {
            dimensionLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "dimension_label" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDimensionLabel {
          get { return dimensionLabel_ != null; }
        }
        /// <summary>Clears the value of the "dimension_label" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDimensionLabel() {
          dimensionLabel_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ReplicaMetadataPB);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ReplicaMetadataPB other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TsIdx != other.TsIdx) return false;
          if (Role != other.Role) return false;
          if (DimensionLabel != other.DimensionLabel) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTsIdx) hash ^= TsIdx.GetHashCode();
          if (HasRole) hash ^= Role.GetHashCode();
          if (HasDimensionLabel) hash ^= DimensionLabel.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          output.WriteRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasTsIdx) {
            output.WriteRawTag(8);
            output.WriteUInt32(TsIdx);
          }
          if (HasRole) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Role);
          }
          if (HasDimensionLabel) {
            output.WriteRawTag(26);
            output.WriteString(DimensionLabel);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasTsIdx) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TsIdx);
          }
          if (HasRole) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Role);
          }
          if (HasDimensionLabel) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DimensionLabel);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ReplicaMetadataPB other) {
          if (other == null) {
            return;
          }
          if (other.HasTsIdx) {
            TsIdx = other.TsIdx;
          }
          if (other.HasRole) {
            Role = other.Role;
          }
          if (other.HasDimensionLabel) {
            DimensionLabel = other.DimensionLabel;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          input.ReadRawMessage(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                TsIdx = input.ReadUInt32();
                break;
              }
              case 16: {
                Role = (global::Knet.Kudu.Client.Protobuf.Consensus.RaftPeerPB.Types.Role) input.ReadEnum();
                break;
              }
              case 26: {
                DimensionLabel = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Serialization format for client scan tokens. Scan tokens are serializable
  /// scan descriptors that are used by query engines to plan a set of parallizable
  /// scanners that are executed on remote task runners. The scan token protobuf
  /// format includes all of the information necessary to recreate a scanner in the
  /// remote task.
  /// </summary>
  public sealed partial class ScanTokenPB : pb::IMessage<ScanTokenPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<ScanTokenPB> _parser = new pb::MessageParser<ScanTokenPB>(() => new ScanTokenPB());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScanTokenPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Client.ClientReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScanTokenPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScanTokenPB(ScanTokenPB other) : this() {
      _hasBits0 = other._hasBits0;
      featureFlags_ = other.featureFlags_.Clone();
      tableId_ = other.tableId_;
      tableName_ = other.tableName_;
      tableMetadata_ = other.tableMetadata_ != null ? other.tableMetadata_.Clone() : null;
      tabletMetadata_ = other.tabletMetadata_ != null ? other.tabletMetadata_.Clone() : null;
      projectedColumnIdx_ = other.projectedColumnIdx_.Clone();
      projectedColumns_ = other.projectedColumns_.Clone();
      columnPredicates_ = other.columnPredicates_.Clone();
      lowerBoundPrimaryKey_ = other.lowerBoundPrimaryKey_;
      upperBoundPrimaryKey_ = other.upperBoundPrimaryKey_;
      lowerBoundPartitionKey_ = other.lowerBoundPartitionKey_;
      upperBoundPartitionKey_ = other.upperBoundPartitionKey_;
      limit_ = other.limit_;
      readMode_ = other.readMode_;
      snapTimestamp_ = other.snapTimestamp_;
      snapStartTimestamp_ = other.snapStartTimestamp_;
      propagatedTimestamp_ = other.propagatedTimestamp_;
      cacheBlocks_ = other.cacheBlocks_;
      faultTolerant_ = other.faultTolerant_;
      batchSizeBytes_ = other.batchSizeBytes_;
      replicaSelection_ = other.replicaSelection_;
      scanRequestTimeoutMs_ = other.scanRequestTimeoutMs_;
      keepAlivePeriodMs_ = other.keepAlivePeriodMs_;
      authzToken_ = other.authzToken_ != null ? other.authzToken_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScanTokenPB Clone() {
      return new ScanTokenPB(this);
    }

    /// <summary>Field number for the "feature_flags" field.</summary>
    public const int FeatureFlagsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Types.Feature> _repeated_featureFlags_codec
        = pb::FieldCodec.ForEnum(8, x => (int) x, x => (global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Types.Feature) x);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Types.Feature> featureFlags_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Types.Feature>();
    /// <summary>
    /// The feature set used by this scan token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.Client.ScanTokenPB.Types.Feature> FeatureFlags {
      get { return featureFlags_; }
    }

    /// <summary>Field number for the "table_id" field.</summary>
    public const int TableIdFieldNumber = 20;
    private readonly static string TableIdDefaultValue = "";

    private string tableId_;
    /// <summary>
    /// The table to scan. To remain backwards compatible, clients should set
    /// both the table name and the table id, but should prefer to use the id
    /// when rehydrating the scanner because the id cannot change.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TableId {
      get { return tableId_ ?? TableIdDefaultValue; }
      set {
        tableId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "table_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTableId {
      get { return tableId_ != null; }
    }
    /// <summary>Clears the value of the "table_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTableId() {
      tableId_ = null;
    }

    /// <summary>Field number for the "table_name" field.</summary>
    public const int TableNameFieldNumber = 2;
    private readonly static string TableNameDefaultValue = "";

    private string tableName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TableName {
      get { return tableName_ ?? TableNameDefaultValue; }
      set {
        tableName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "table_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTableName {
      get { return tableName_ != null; }
    }
    /// <summary>Clears the value of the "table_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTableName() {
      tableName_ = null;
    }

    /// <summary>Field number for the "table_metadata" field.</summary>
    public const int TableMetadataFieldNumber = 21;
    private global::Knet.Kudu.Client.Protobuf.Client.TableMetadataPB tableMetadata_;
    /// <summary>
    /// Optional table metadata. If provided the scan token can avoid
    /// an extra GetTableSchema RPC call to the master.
    /// If set, neither table_id or table_name above are required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Client.TableMetadataPB TableMetadata {
      get { return tableMetadata_; }
      set {
        tableMetadata_ = value;
      }
    }

    /// <summary>Field number for the "tablet_metadata" field.</summary>
    public const int TabletMetadataFieldNumber = 22;
    private global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB tabletMetadata_;
    /// <summary>
    /// Optional tablet metadata. If provided the scan token can avoid
    /// an extra GetTableLocations RPC call to the master.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB TabletMetadata {
      get { return tabletMetadata_; }
      set {
        tabletMetadata_ = value;
      }
    }

    /// <summary>Field number for the "projected_column_idx" field.</summary>
    public const int ProjectedColumnIdxFieldNumber = 23;
    private static readonly pb::FieldCodec<int> _repeated_projectedColumnIdx_codec
        = pb::FieldCodec.ForInt32(184);
    private readonly pbc::RepeatedField<int> projectedColumnIdx_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// The index of which columns in table_metadata to select.
    /// This can be used in place of projected_columns if this
    /// scan token has table_metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> ProjectedColumnIdx {
      get { return projectedColumnIdx_; }
    }

    /// <summary>Field number for the "projected_columns" field.</summary>
    public const int ProjectedColumnsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.ColumnSchemaPB> _repeated_projectedColumns_codec
        = pb::FieldCodec.ForMessage(26, global::Knet.Kudu.Client.Protobuf.ColumnSchemaPB.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.ColumnSchemaPB> projectedColumns_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.ColumnSchemaPB>();
    /// <summary>
    /// Which columns to select.
    /// if this is an empty list, no data will be returned, but the num_rows
    /// field of the returned RowBlock will indicate how many rows passed
    /// the predicates. Note that in some cases, the scan may still require
    /// multiple round-trips, and the caller must aggregate the counts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.ColumnSchemaPB> ProjectedColumns {
      get { return projectedColumns_; }
    }

    /// <summary>Field number for the "column_predicates" field.</summary>
    public const int ColumnPredicatesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Knet.Kudu.Client.Protobuf.ColumnPredicatePB> _repeated_columnPredicates_codec
        = pb::FieldCodec.ForMessage(34, global::Knet.Kudu.Client.Protobuf.ColumnPredicatePB.Parser);
    private readonly pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.ColumnPredicatePB> columnPredicates_ = new pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.ColumnPredicatePB>();
    /// <summary>
    /// Any column predicates to enforce.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Knet.Kudu.Client.Protobuf.ColumnPredicatePB> ColumnPredicates {
      get { return columnPredicates_; }
    }

    /// <summary>Field number for the "lower_bound_primary_key" field.</summary>
    public const int LowerBoundPrimaryKeyFieldNumber = 5;
    private readonly static pb::ByteString LowerBoundPrimaryKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString lowerBoundPrimaryKey_;
    /// <summary>
    /// Encoded primary key to begin scanning at (inclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString LowerBoundPrimaryKey {
      get { return lowerBoundPrimaryKey_ ?? LowerBoundPrimaryKeyDefaultValue; }
      set {
        lowerBoundPrimaryKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "lower_bound_primary_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLowerBoundPrimaryKey {
      get { return lowerBoundPrimaryKey_ != null; }
    }
    /// <summary>Clears the value of the "lower_bound_primary_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLowerBoundPrimaryKey() {
      lowerBoundPrimaryKey_ = null;
    }

    /// <summary>Field number for the "upper_bound_primary_key" field.</summary>
    public const int UpperBoundPrimaryKeyFieldNumber = 6;
    private readonly static pb::ByteString UpperBoundPrimaryKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString upperBoundPrimaryKey_;
    /// <summary>
    /// Encoded primary key to stop scanning at (exclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString UpperBoundPrimaryKey {
      get { return upperBoundPrimaryKey_ ?? UpperBoundPrimaryKeyDefaultValue; }
      set {
        upperBoundPrimaryKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "upper_bound_primary_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUpperBoundPrimaryKey {
      get { return upperBoundPrimaryKey_ != null; }
    }
    /// <summary>Clears the value of the "upper_bound_primary_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUpperBoundPrimaryKey() {
      upperBoundPrimaryKey_ = null;
    }

    /// <summary>Field number for the "lower_bound_partition_key" field.</summary>
    public const int LowerBoundPartitionKeyFieldNumber = 7;
    private readonly static pb::ByteString LowerBoundPartitionKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString lowerBoundPartitionKey_;
    /// <summary>
    /// Encoded partition key to begin scanning at (inclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString LowerBoundPartitionKey {
      get { return lowerBoundPartitionKey_ ?? LowerBoundPartitionKeyDefaultValue; }
      set {
        lowerBoundPartitionKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "lower_bound_partition_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLowerBoundPartitionKey {
      get { return lowerBoundPartitionKey_ != null; }
    }
    /// <summary>Clears the value of the "lower_bound_partition_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLowerBoundPartitionKey() {
      lowerBoundPartitionKey_ = null;
    }

    /// <summary>Field number for the "upper_bound_partition_key" field.</summary>
    public const int UpperBoundPartitionKeyFieldNumber = 8;
    private readonly static pb::ByteString UpperBoundPartitionKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString upperBoundPartitionKey_;
    /// <summary>
    /// Encoded partition key to stop scanning at (exclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString UpperBoundPartitionKey {
      get { return upperBoundPartitionKey_ ?? UpperBoundPartitionKeyDefaultValue; }
      set {
        upperBoundPartitionKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "upper_bound_partition_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUpperBoundPartitionKey {
      get { return upperBoundPartitionKey_ != null; }
    }
    /// <summary>Clears the value of the "upper_bound_partition_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUpperBoundPartitionKey() {
      upperBoundPartitionKey_ = null;
    }

    /// <summary>Field number for the "limit" field.</summary>
    public const int LimitFieldNumber = 9;
    private readonly static ulong LimitDefaultValue = 0UL;

    private ulong limit_;
    /// <summary>
    /// The maximum number of rows to scan.
    /// The scanner will automatically stop yielding results and close
    /// itself after reaching this number of result rows.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Limit {
      get { if ((_hasBits0 & 1) != 0) { return limit_; } else { return LimitDefaultValue; } }
      set {
        _hasBits0 |= 1;
        limit_ = value;
      }
    }
    /// <summary>Gets whether the "limit" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLimit {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "limit" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLimit() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "read_mode" field.</summary>
    public const int ReadModeFieldNumber = 10;
    private readonly static global::Knet.Kudu.Client.Protobuf.ReadModePB ReadModeDefaultValue = global::Knet.Kudu.Client.Protobuf.ReadModePB.ReadLatest;

    private global::Knet.Kudu.Client.Protobuf.ReadModePB readMode_;
    /// <summary>
    /// The read mode for this scan request.
    /// See common.proto for further information about read modes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.ReadModePB ReadMode {
      get { if ((_hasBits0 & 2) != 0) { return readMode_; } else { return ReadModeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readMode_ = value;
      }
    }
    /// <summary>Gets whether the "read_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasReadMode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "read_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearReadMode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "snap_timestamp" field.</summary>
    public const int SnapTimestampFieldNumber = 11;
    private readonly static ulong SnapTimestampDefaultValue = 0UL;

    private ulong snapTimestamp_;
    /// <summary>
    /// The requested snapshot timestamp. This is only used
    /// when the read mode is set to READ_AT_SNAPSHOT.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong SnapTimestamp {
      get { if ((_hasBits0 & 4) != 0) { return snapTimestamp_; } else { return SnapTimestampDefaultValue; } }
      set {
        _hasBits0 |= 4;
        snapTimestamp_ = value;
      }
    }
    /// <summary>Gets whether the "snap_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSnapTimestamp {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "snap_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSnapTimestamp() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "snap_start_timestamp" field.</summary>
    public const int SnapStartTimestampFieldNumber = 19;
    private readonly static ulong SnapStartTimestampDefaultValue = 0UL;

    private ulong snapStartTimestamp_;
    /// <summary>
    /// The requested snapshot start timestamp. This is only used
    /// when the read mode is set to READ_AT_SNAPSHOT.
    /// Setting this indicates the scan should be a diff scan, the
    /// snap_timestamp will be used as the snapshot end timestamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong SnapStartTimestamp {
      get { if ((_hasBits0 & 1024) != 0) { return snapStartTimestamp_; } else { return SnapStartTimestampDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        snapStartTimestamp_ = value;
      }
    }
    /// <summary>Gets whether the "snap_start_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSnapStartTimestamp {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "snap_start_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSnapStartTimestamp() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "propagated_timestamp" field.</summary>
    public const int PropagatedTimestampFieldNumber = 12;
    private readonly static ulong PropagatedTimestampDefaultValue = 0UL;

    private ulong propagatedTimestamp_;
    /// <summary>
    /// Sent by clients which previously executed CLIENT_PROPAGATED writes.
    /// This updates the server's time so that no op will be assigned
    /// a timestamp lower than or equal to 'previous_known_timestamp'
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong PropagatedTimestamp {
      get { if ((_hasBits0 & 8) != 0) { return propagatedTimestamp_; } else { return PropagatedTimestampDefaultValue; } }
      set {
        _hasBits0 |= 8;
        propagatedTimestamp_ = value;
      }
    }
    /// <summary>Gets whether the "propagated_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPropagatedTimestamp {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "propagated_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPropagatedTimestamp() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "cache_blocks" field.</summary>
    public const int CacheBlocksFieldNumber = 13;
    private readonly static bool CacheBlocksDefaultValue = true;

    private bool cacheBlocks_;
    /// <summary>
    /// Whether data blocks will be cached when read from the files or discarded after use.
    /// Disable this to lower cache churn when doing large scans.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool CacheBlocks {
      get { if ((_hasBits0 & 16) != 0) { return cacheBlocks_; } else { return CacheBlocksDefaultValue; } }
      set {
        _hasBits0 |= 16;
        cacheBlocks_ = value;
      }
    }
    /// <summary>Gets whether the "cache_blocks" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCacheBlocks {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "cache_blocks" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCacheBlocks() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "fault_tolerant" field.</summary>
    public const int FaultTolerantFieldNumber = 14;
    private readonly static bool FaultTolerantDefaultValue = false;

    private bool faultTolerant_;
    /// <summary>
    /// Whether the scan should be fault tolerant.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FaultTolerant {
      get { if ((_hasBits0 & 32) != 0) { return faultTolerant_; } else { return FaultTolerantDefaultValue; } }
      set {
        _hasBits0 |= 32;
        faultTolerant_ = value;
      }
    }
    /// <summary>Gets whether the "fault_tolerant" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFaultTolerant {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "fault_tolerant" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFaultTolerant() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "batch_size_bytes" field.</summary>
    public const int BatchSizeBytesFieldNumber = 15;
    private readonly static uint BatchSizeBytesDefaultValue = 0;

    private uint batchSizeBytes_;
    /// <summary>
    /// The maximum number of bytes to send in the response.
    /// This is a hint, not a requirement: the server may send
    /// arbitrarily fewer or more bytes than requested.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BatchSizeBytes {
      get { if ((_hasBits0 & 64) != 0) { return batchSizeBytes_; } else { return BatchSizeBytesDefaultValue; } }
      set {
        _hasBits0 |= 64;
        batchSizeBytes_ = value;
      }
    }
    /// <summary>Gets whether the "batch_size_bytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBatchSizeBytes {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "batch_size_bytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBatchSizeBytes() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "replica_selection" field.</summary>
    public const int ReplicaSelectionFieldNumber = 16;
    private readonly static global::Knet.Kudu.Client.Protobuf.ReplicaSelectionPB ReplicaSelectionDefaultValue = global::Knet.Kudu.Client.Protobuf.ReplicaSelectionPB.LeaderOnly;

    private global::Knet.Kudu.Client.Protobuf.ReplicaSelectionPB replicaSelection_;
    /// <summary>
    /// The replica selection policy for the scan request.
    /// See common.proto for further information about replica selections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.ReplicaSelectionPB ReplicaSelection {
      get { if ((_hasBits0 & 128) != 0) { return replicaSelection_; } else { return ReplicaSelectionDefaultValue; } }
      set {
        _hasBits0 |= 128;
        replicaSelection_ = value;
      }
    }
    /// <summary>Gets whether the "replica_selection" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasReplicaSelection {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "replica_selection" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearReplicaSelection() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "scan_request_timeout_ms" field.</summary>
    public const int ScanRequestTimeoutMsFieldNumber = 17;
    private readonly static long ScanRequestTimeoutMsDefaultValue = 0L;

    private long scanRequestTimeoutMs_;
    /// <summary>
    /// The maximum length of time, in milliseconds, that each scan request to a
    /// server can take. If not set, the default value is controlled by the client
    /// scanner implementation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ScanRequestTimeoutMs {
      get { if ((_hasBits0 & 256) != 0) { return scanRequestTimeoutMs_; } else { return ScanRequestTimeoutMsDefaultValue; } }
      set {
        _hasBits0 |= 256;
        scanRequestTimeoutMs_ = value;
      }
    }
    /// <summary>Gets whether the "scan_request_timeout_ms" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScanRequestTimeoutMs {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "scan_request_timeout_ms" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScanRequestTimeoutMs() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "keep_alive_period_ms" field.</summary>
    public const int KeepAlivePeriodMsFieldNumber = 18;
    private readonly static long KeepAlivePeriodMsDefaultValue = 0L;

    private long keepAlivePeriodMs_;
    /// <summary>
    /// The period, in milliseconds, at which to send keep-alive requests to the tablet
    /// server to ensure this scanner won't time out.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long KeepAlivePeriodMs {
      get { if ((_hasBits0 & 512) != 0) { return keepAlivePeriodMs_; } else { return KeepAlivePeriodMsDefaultValue; } }
      set {
        _hasBits0 |= 512;
        keepAlivePeriodMs_ = value;
      }
    }
    /// <summary>Gets whether the "keep_alive_period_ms" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasKeepAlivePeriodMs {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "keep_alive_period_ms" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearKeepAlivePeriodMs() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "authz_token" field.</summary>
    public const int AuthzTokenFieldNumber = 24;
    private global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB authzToken_;
    /// <summary>
    /// An authorization token with which to authorize the scan requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB AuthzToken {
      get { return authzToken_; }
      set {
        authzToken_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScanTokenPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScanTokenPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!featureFlags_.Equals(other.featureFlags_)) return false;
      if (TableId != other.TableId) return false;
      if (TableName != other.TableName) return false;
      if (!object.Equals(TableMetadata, other.TableMetadata)) return false;
      if (!object.Equals(TabletMetadata, other.TabletMetadata)) return false;
      if(!projectedColumnIdx_.Equals(other.projectedColumnIdx_)) return false;
      if(!projectedColumns_.Equals(other.projectedColumns_)) return false;
      if(!columnPredicates_.Equals(other.columnPredicates_)) return false;
      if (LowerBoundPrimaryKey != other.LowerBoundPrimaryKey) return false;
      if (UpperBoundPrimaryKey != other.UpperBoundPrimaryKey) return false;
      if (LowerBoundPartitionKey != other.LowerBoundPartitionKey) return false;
      if (UpperBoundPartitionKey != other.UpperBoundPartitionKey) return false;
      if (Limit != other.Limit) return false;
      if (ReadMode != other.ReadMode) return false;
      if (SnapTimestamp != other.SnapTimestamp) return false;
      if (SnapStartTimestamp != other.SnapStartTimestamp) return false;
      if (PropagatedTimestamp != other.PropagatedTimestamp) return false;
      if (CacheBlocks != other.CacheBlocks) return false;
      if (FaultTolerant != other.FaultTolerant) return false;
      if (BatchSizeBytes != other.BatchSizeBytes) return false;
      if (ReplicaSelection != other.ReplicaSelection) return false;
      if (ScanRequestTimeoutMs != other.ScanRequestTimeoutMs) return false;
      if (KeepAlivePeriodMs != other.KeepAlivePeriodMs) return false;
      if (!object.Equals(AuthzToken, other.AuthzToken)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= featureFlags_.GetHashCode();
      if (HasTableId) hash ^= TableId.GetHashCode();
      if (HasTableName) hash ^= TableName.GetHashCode();
      if (tableMetadata_ != null) hash ^= TableMetadata.GetHashCode();
      if (tabletMetadata_ != null) hash ^= TabletMetadata.GetHashCode();
      hash ^= projectedColumnIdx_.GetHashCode();
      hash ^= projectedColumns_.GetHashCode();
      hash ^= columnPredicates_.GetHashCode();
      if (HasLowerBoundPrimaryKey) hash ^= LowerBoundPrimaryKey.GetHashCode();
      if (HasUpperBoundPrimaryKey) hash ^= UpperBoundPrimaryKey.GetHashCode();
      if (HasLowerBoundPartitionKey) hash ^= LowerBoundPartitionKey.GetHashCode();
      if (HasUpperBoundPartitionKey) hash ^= UpperBoundPartitionKey.GetHashCode();
      if (HasLimit) hash ^= Limit.GetHashCode();
      if (HasReadMode) hash ^= ReadMode.GetHashCode();
      if (HasSnapTimestamp) hash ^= SnapTimestamp.GetHashCode();
      if (HasSnapStartTimestamp) hash ^= SnapStartTimestamp.GetHashCode();
      if (HasPropagatedTimestamp) hash ^= PropagatedTimestamp.GetHashCode();
      if (HasCacheBlocks) hash ^= CacheBlocks.GetHashCode();
      if (HasFaultTolerant) hash ^= FaultTolerant.GetHashCode();
      if (HasBatchSizeBytes) hash ^= BatchSizeBytes.GetHashCode();
      if (HasReplicaSelection) hash ^= ReplicaSelection.GetHashCode();
      if (HasScanRequestTimeoutMs) hash ^= ScanRequestTimeoutMs.GetHashCode();
      if (HasKeepAlivePeriodMs) hash ^= KeepAlivePeriodMs.GetHashCode();
      if (authzToken_ != null) hash ^= AuthzToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      featureFlags_.WriteTo(ref output, _repeated_featureFlags_codec);
      if (HasTableName) {
        output.WriteRawTag(18);
        output.WriteString(TableName);
      }
      projectedColumns_.WriteTo(ref output, _repeated_projectedColumns_codec);
      columnPredicates_.WriteTo(ref output, _repeated_columnPredicates_codec);
      if (HasLowerBoundPrimaryKey) {
        output.WriteRawTag(42);
        output.WriteBytes(LowerBoundPrimaryKey);
      }
      if (HasUpperBoundPrimaryKey) {
        output.WriteRawTag(50);
        output.WriteBytes(UpperBoundPrimaryKey);
      }
      if (HasLowerBoundPartitionKey) {
        output.WriteRawTag(58);
        output.WriteBytes(LowerBoundPartitionKey);
      }
      if (HasUpperBoundPartitionKey) {
        output.WriteRawTag(66);
        output.WriteBytes(UpperBoundPartitionKey);
      }
      if (HasLimit) {
        output.WriteRawTag(72);
        output.WriteUInt64(Limit);
      }
      if (HasReadMode) {
        output.WriteRawTag(80);
        output.WriteEnum((int) ReadMode);
      }
      if (HasSnapTimestamp) {
        output.WriteRawTag(89);
        output.WriteFixed64(SnapTimestamp);
      }
      if (HasPropagatedTimestamp) {
        output.WriteRawTag(97);
        output.WriteFixed64(PropagatedTimestamp);
      }
      if (HasCacheBlocks) {
        output.WriteRawTag(104);
        output.WriteBool(CacheBlocks);
      }
      if (HasFaultTolerant) {
        output.WriteRawTag(112);
        output.WriteBool(FaultTolerant);
      }
      if (HasBatchSizeBytes) {
        output.WriteRawTag(120);
        output.WriteUInt32(BatchSizeBytes);
      }
      if (HasReplicaSelection) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) ReplicaSelection);
      }
      if (HasScanRequestTimeoutMs) {
        output.WriteRawTag(136, 1);
        output.WriteInt64(ScanRequestTimeoutMs);
      }
      if (HasKeepAlivePeriodMs) {
        output.WriteRawTag(144, 1);
        output.WriteInt64(KeepAlivePeriodMs);
      }
      if (HasSnapStartTimestamp) {
        output.WriteRawTag(153, 1);
        output.WriteFixed64(SnapStartTimestamp);
      }
      if (HasTableId) {
        output.WriteRawTag(162, 1);
        output.WriteString(TableId);
      }
      if (tableMetadata_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(TableMetadata);
      }
      if (tabletMetadata_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(TabletMetadata);
      }
      projectedColumnIdx_.WriteTo(ref output, _repeated_projectedColumnIdx_codec);
      if (authzToken_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(AuthzToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += featureFlags_.CalculateSize(_repeated_featureFlags_codec);
      if (HasTableId) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TableId);
      }
      if (HasTableName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TableName);
      }
      if (tableMetadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TableMetadata);
      }
      if (tabletMetadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TabletMetadata);
      }
      size += projectedColumnIdx_.CalculateSize(_repeated_projectedColumnIdx_codec);
      size += projectedColumns_.CalculateSize(_repeated_projectedColumns_codec);
      size += columnPredicates_.CalculateSize(_repeated_columnPredicates_codec);
      if (HasLowerBoundPrimaryKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(LowerBoundPrimaryKey);
      }
      if (HasUpperBoundPrimaryKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(UpperBoundPrimaryKey);
      }
      if (HasLowerBoundPartitionKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(LowerBoundPartitionKey);
      }
      if (HasUpperBoundPartitionKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(UpperBoundPartitionKey);
      }
      if (HasLimit) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Limit);
      }
      if (HasReadMode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ReadMode);
      }
      if (HasSnapTimestamp) {
        size += 1 + 8;
      }
      if (HasSnapStartTimestamp) {
        size += 2 + 8;
      }
      if (HasPropagatedTimestamp) {
        size += 1 + 8;
      }
      if (HasCacheBlocks) {
        size += 1 + 1;
      }
      if (HasFaultTolerant) {
        size += 1 + 1;
      }
      if (HasBatchSizeBytes) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BatchSizeBytes);
      }
      if (HasReplicaSelection) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ReplicaSelection);
      }
      if (HasScanRequestTimeoutMs) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(ScanRequestTimeoutMs);
      }
      if (HasKeepAlivePeriodMs) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(KeepAlivePeriodMs);
      }
      if (authzToken_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AuthzToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScanTokenPB other) {
      if (other == null) {
        return;
      }
      featureFlags_.Add(other.featureFlags_);
      if (other.HasTableId) {
        TableId = other.TableId;
      }
      if (other.HasTableName) {
        TableName = other.TableName;
      }
      if (other.tableMetadata_ != null) {
        if (tableMetadata_ == null) {
          TableMetadata = new global::Knet.Kudu.Client.Protobuf.Client.TableMetadataPB();
        }
        TableMetadata.MergeFrom(other.TableMetadata);
      }
      if (other.tabletMetadata_ != null) {
        if (tabletMetadata_ == null) {
          TabletMetadata = new global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB();
        }
        TabletMetadata.MergeFrom(other.TabletMetadata);
      }
      projectedColumnIdx_.Add(other.projectedColumnIdx_);
      projectedColumns_.Add(other.projectedColumns_);
      columnPredicates_.Add(other.columnPredicates_);
      if (other.HasLowerBoundPrimaryKey) {
        LowerBoundPrimaryKey = other.LowerBoundPrimaryKey;
      }
      if (other.HasUpperBoundPrimaryKey) {
        UpperBoundPrimaryKey = other.UpperBoundPrimaryKey;
      }
      if (other.HasLowerBoundPartitionKey) {
        LowerBoundPartitionKey = other.LowerBoundPartitionKey;
      }
      if (other.HasUpperBoundPartitionKey) {
        UpperBoundPartitionKey = other.UpperBoundPartitionKey;
      }
      if (other.HasLimit) {
        Limit = other.Limit;
      }
      if (other.HasReadMode) {
        ReadMode = other.ReadMode;
      }
      if (other.HasSnapTimestamp) {
        SnapTimestamp = other.SnapTimestamp;
      }
      if (other.HasSnapStartTimestamp) {
        SnapStartTimestamp = other.SnapStartTimestamp;
      }
      if (other.HasPropagatedTimestamp) {
        PropagatedTimestamp = other.PropagatedTimestamp;
      }
      if (other.HasCacheBlocks) {
        CacheBlocks = other.CacheBlocks;
      }
      if (other.HasFaultTolerant) {
        FaultTolerant = other.FaultTolerant;
      }
      if (other.HasBatchSizeBytes) {
        BatchSizeBytes = other.BatchSizeBytes;
      }
      if (other.HasReplicaSelection) {
        ReplicaSelection = other.ReplicaSelection;
      }
      if (other.HasScanRequestTimeoutMs) {
        ScanRequestTimeoutMs = other.ScanRequestTimeoutMs;
      }
      if (other.HasKeepAlivePeriodMs) {
        KeepAlivePeriodMs = other.KeepAlivePeriodMs;
      }
      if (other.authzToken_ != null) {
        if (authzToken_ == null) {
          AuthzToken = new global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB();
        }
        AuthzToken.MergeFrom(other.AuthzToken);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            featureFlags_.AddEntriesFrom(ref input, _repeated_featureFlags_codec);
            break;
          }
          case 18: {
            TableName = input.ReadString();
            break;
          }
          case 26: {
            projectedColumns_.AddEntriesFrom(ref input, _repeated_projectedColumns_codec);
            break;
          }
          case 34: {
            columnPredicates_.AddEntriesFrom(ref input, _repeated_columnPredicates_codec);
            break;
          }
          case 42: {
            LowerBoundPrimaryKey = input.ReadBytes();
            break;
          }
          case 50: {
            UpperBoundPrimaryKey = input.ReadBytes();
            break;
          }
          case 58: {
            LowerBoundPartitionKey = input.ReadBytes();
            break;
          }
          case 66: {
            UpperBoundPartitionKey = input.ReadBytes();
            break;
          }
          case 72: {
            Limit = input.ReadUInt64();
            break;
          }
          case 80: {
            ReadMode = (global::Knet.Kudu.Client.Protobuf.ReadModePB) input.ReadEnum();
            break;
          }
          case 89: {
            SnapTimestamp = input.ReadFixed64();
            break;
          }
          case 97: {
            PropagatedTimestamp = input.ReadFixed64();
            break;
          }
          case 104: {
            CacheBlocks = input.ReadBool();
            break;
          }
          case 112: {
            FaultTolerant = input.ReadBool();
            break;
          }
          case 120: {
            BatchSizeBytes = input.ReadUInt32();
            break;
          }
          case 128: {
            ReplicaSelection = (global::Knet.Kudu.Client.Protobuf.ReplicaSelectionPB) input.ReadEnum();
            break;
          }
          case 136: {
            ScanRequestTimeoutMs = input.ReadInt64();
            break;
          }
          case 144: {
            KeepAlivePeriodMs = input.ReadInt64();
            break;
          }
          case 153: {
            SnapStartTimestamp = input.ReadFixed64();
            break;
          }
          case 162: {
            TableId = input.ReadString();
            break;
          }
          case 170: {
            if (tableMetadata_ == null) {
              TableMetadata = new global::Knet.Kudu.Client.Protobuf.Client.TableMetadataPB();
            }
            input.ReadMessage(TableMetadata);
            break;
          }
          case 178: {
            if (tabletMetadata_ == null) {
              TabletMetadata = new global::Knet.Kudu.Client.Protobuf.Client.TabletMetadataPB();
            }
            input.ReadMessage(TabletMetadata);
            break;
          }
          case 186:
          case 184: {
            projectedColumnIdx_.AddEntriesFrom(ref input, _repeated_projectedColumnIdx_codec);
            break;
          }
          case 194: {
            if (authzToken_ == null) {
              AuthzToken = new global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB();
            }
            input.ReadMessage(AuthzToken);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ScanTokenPB message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Features used by the scan token message. Every time the ScanTokenPB message
      /// is updated with a new feature, the feature should be added to this enum, so
      /// that clients that lack the feature can recognize when they receive a token
      /// that uses unknown features.
      /// </summary>
      public enum Feature {
        [pbr::OriginalName("Unknown")] Unknown = 0,
      }

    }
    #endregion

  }

  /// <summary>
  /// All of the data necessary to authenticate to a cluster from a client with
  /// no Kerberos credentials.
  /// </summary>
  public sealed partial class AuthenticationCredentialsPB : pb::IMessage<AuthenticationCredentialsPB>
      , pb::IBufferMessage
  {
    private static readonly pb::MessageParser<AuthenticationCredentialsPB> _parser = new pb::MessageParser<AuthenticationCredentialsPB>(() => new AuthenticationCredentialsPB());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AuthenticationCredentialsPB> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Knet.Kudu.Client.Protobuf.Client.ClientReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthenticationCredentialsPB() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthenticationCredentialsPB(AuthenticationCredentialsPB other) : this() {
      authnToken_ = other.authnToken_ != null ? other.authnToken_.Clone() : null;
      realUser_ = other.realUser_;
      caCertDers_ = other.caCertDers_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AuthenticationCredentialsPB Clone() {
      return new AuthenticationCredentialsPB(this);
    }

    /// <summary>Field number for the "authn_token" field.</summary>
    public const int AuthnTokenFieldNumber = 1;
    private global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB authnToken_;
    /// <summary>
    /// A signed token with user credentials issued by the master.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB AuthnToken {
      get { return authnToken_; }
      set {
        authnToken_ = value;
      }
    }

    /// <summary>Field number for the "real_user" field.</summary>
    public const int RealUserFieldNumber = 3;
    private readonly static string RealUserDefaultValue = "";

    private string realUser_;
    /// <summary>
    /// The real user name, used for SASL PLAIN authentication.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RealUser {
      get { return realUser_ ?? RealUserDefaultValue; }
      set {
        realUser_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "real_user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRealUser {
      get { return realUser_ != null; }
    }
    /// <summary>Clears the value of the "real_user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRealUser() {
      realUser_ = null;
    }

    /// <summary>Field number for the "ca_cert_ders" field.</summary>
    public const int CaCertDersFieldNumber = 2;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_caCertDers_codec
        = pb::FieldCodec.ForBytes(18);
    private readonly pbc::RepeatedField<pb::ByteString> caCertDers_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    /// Trusted root CA certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> CaCertDers {
      get { return caCertDers_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AuthenticationCredentialsPB);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AuthenticationCredentialsPB other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AuthnToken, other.AuthnToken)) return false;
      if (RealUser != other.RealUser) return false;
      if(!caCertDers_.Equals(other.caCertDers_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (authnToken_ != null) hash ^= AuthnToken.GetHashCode();
      if (HasRealUser) hash ^= RealUser.GetHashCode();
      hash ^= caCertDers_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      output.WriteRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (authnToken_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AuthnToken);
      }
      caCertDers_.WriteTo(ref output, _repeated_caCertDers_codec);
      if (HasRealUser) {
        output.WriteRawTag(26);
        output.WriteString(RealUser);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (authnToken_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthnToken);
      }
      if (HasRealUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RealUser);
      }
      size += caCertDers_.CalculateSize(_repeated_caCertDers_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AuthenticationCredentialsPB other) {
      if (other == null) {
        return;
      }
      if (other.authnToken_ != null) {
        if (authnToken_ == null) {
          AuthnToken = new global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB();
        }
        AuthnToken.MergeFrom(other.AuthnToken);
      }
      if (other.HasRealUser) {
        RealUser = other.RealUser;
      }
      caCertDers_.Add(other.caCertDers_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      input.ReadRawMessage(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (authnToken_ == null) {
              AuthnToken = new global::Knet.Kudu.Client.Protobuf.Security.SignedTokenPB();
            }
            input.ReadMessage(AuthnToken);
            break;
          }
          case 18: {
            caCertDers_.AddEntriesFrom(ref input, _repeated_caCertDers_codec);
            break;
          }
          case 26: {
            RealUser = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
